<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Grace</name>
    </assembly>
    <members>
        <member name="T:Grace.Data.IExraDataContainerExtensions">
            <summary>
            C# extension class for IExtraDataContainer
            </summary>
        </member>
        <member name="M:Grace.Data.IExraDataContainerExtensions.GetExtraDataOrDefaultValue``1(Grace.Data.IExtraDataContainer,System.Object,``0)">
            <summary>
            Get a value from extra data or return default. will convert 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="container"></param>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Data.IExtraDataContainer">
            <summary>
            Used to store extra data, implemented by IInjectionContext and IExportLocator
            </summary>
        </member>
        <member name="P:Grace.Data.IExtraDataContainer.Keys">
            <summary>
            Keys for data
            </summary>
        </member>
        <member name="P:Grace.Data.IExtraDataContainer.Values">
            <summary>
            Values for data
            </summary>
        </member>
        <member name="P:Grace.Data.IExtraDataContainer.KeyValuePairs">
            <summary>
            Enumeration of all the key value pairs
            </summary>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.GetExtraData(System.Object)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="key">key of the data object to get</param>
            <returns>data value</returns>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.SetExtraData(System.Object,System.Object,System.Boolean)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="key">object name</param>
            <param name="newValue">new object value</param>
            <param name="replaceIfExists">replace value if key exists</param>
            <returns>the final value of key</returns>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableArray">
            <summary>
            Immutable array create methods
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray.Create``1(``0[])">
            <summary>
            Create an array 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray.From``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a new immutable list from an IEnumerable(T)
            </summary>
            <typeparam name="T">item type</typeparam>
            <param name="list">list of T</param>
            <returns>immutable array</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray.From``1(``0[],System.Int32)">
            <summary>
            Create a new immutable array from an T[]
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ts"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableArray`1">
            <summary>
            Immutable List that implements IReadOnlyList(T)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableArray`1.Empty">
            <summary>
            Empty list
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.GetEnumerator">
            <summary>
            Get an enumerator for this list
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator for this list
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Contains(`0)">
            <summary>
            Contains specified value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy to array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.Count">
            <summary>
            Length of the array
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.Length">
            <summary>
            Length of the array
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.IsReadOnly">
            <summary>
            Immutable list is always read only
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.IndexOf(`0)">
            <summary>
            Index of item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.Item(System.Int32)">
            <summary>
            Index into list
            </summary>
            <param name="index">index for list</param>
            <returns>T at index</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Add(`0)">
            <summary>
            Add T to ImmutableList creating new list
            </summary>
            <param name="value">new T</param>
            <returns>new list</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add and IEnumerable to this list
            </summary>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.AddRange(`0[])">
            <summary>
            Adds a range of T to immutable list creating a new one
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Insert(System.Int32,`0)">
            <summary>
            Insert value into array
            </summary>
            <param name="index"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Explicit(`0[])~Grace.Data.Immutable.ImmutableArray{`0}">
            <summary>
            Implicit conversion from List(T)
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Explicit(Grace.Data.Immutable.ImmutableArray{`0})~`0[]">
            <summary>
            Implicit conversion to List(T)
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.GetHashCode">
            <summary>
            Get hashcode of array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
            <summary>
            Compare arrays
            </summary>
            <param name="other"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Equals(Grace.Data.Immutable.ImmutableArray{`0},Grace.Data.Immutable.ImmutableArray{`0})">
            <summary>Determines whether the specified objects are equal.</summary>
            <returns>true if the specified objects are equal; otherwise, false.</returns>
            <param name="x">The first object of type T to compare.</param>
            <param name="y">The second object of type T to compare.</param>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.GetHashCode(Grace.Data.Immutable.ImmutableArray{`0})">
            <summary>Returns a hash code for the specified object.</summary>
            <returns>A hash code for the specified object.</returns>
            <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
            <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.</exception>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Equality(Grace.Data.Immutable.ImmutableArray{`0},Grace.Data.Immutable.ImmutableArray{`0})">
            <summary>
            Equals override
            </summary>
            <param name="left">left side of statement</param>
            <param name="right">right side of statement</param>
            <returns>true if euqal</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Inequality(Grace.Data.Immutable.ImmutableArray{`0},Grace.Data.Immutable.ImmutableArray{`0})">
            <summary>
            Not equal override
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Equality(System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}},System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}})">
            <summary>
            Equal override for nullable
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Inequality(System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}},System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}})">
            <summary>
            Not equal override for nullable
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableArray`1.ImmutableArrayEnumerator`1">
            <summary>
            Internal enumerator class used to enumerate lists, stacks and queues
            </summary>
            <typeparam name="TItter"></typeparam>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableHashTree">
            <summary>
            Static helper class for immutable hash tree
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree.From``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Create immutable hash tree from IEnuermable
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree.ThreadSafeAdd``2(Grace.Data.Immutable.ImmutableHashTree{``0,``1}@,``0,``1,System.Boolean)">
            <summary>
            Adds value to hash tree
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="destination"></param>
            <param name="key">key to add</param>
            <param name="value">value being added</param>
            <param name="updateIfExists">if true update, if false just leave existing</param>
            <returns>final value for key</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree.ThreadSafeAdd``2(Grace.Data.Immutable.ImmutableHashTree{``0,``1}@,``0,``1,Grace.Data.Immutable.ImmutableHashTree{``0,``1}.UpdateDelegate)">
            <summary>
            Add to tree in a thread safe manner
            </summary>
            <typeparam name="TKey">key type</typeparam>
            <typeparam name="TValue">value type</typeparam>
            <param name="destination">hash tree to add to</param>
            <param name="key">key</param>
            <param name="value">value</param>
            <param name="updateDelegate">update delegate</param>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableHashTree`2">
            <summary>
            Immutable HashTree implementation http://en.wikipedia.org/wiki/AVL_tree
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Empty">
            <summary>
            Empty hashtree, used as the starting point 
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Hash">
            <summary>
            Hash value for this node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Height">
            <summary>
            Height of hashtree node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Key">
            <summary>
            Key value for this hash node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Value">
            <summary>
            Value for this hash node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Conflicts">
            <summary>
            Keys with the same hashcode
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Left">
            <summary>
            Left node of the hash tree
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Right">
            <summary>
            Right node of the hash tree
            </summary>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableHashTree`2.UpdateDelegate">
            <summary>
            Update delegate defines behavior when key already exists
            </summary>
            <param name="currentValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.IterateInOrder(System.Action{`0,`1})">
            <summary>
            Provide an action that will be called for each node in the hash tree
            </summary>
            <param name="iterateAction"></param>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.IterateInOrder">
            <summary>
            Return an enumerable of KVP
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.Add(`0,`1,Grace.Data.Immutable.ImmutableHashTree{`0,`1}.UpdateDelegate)">
            <summary>
            Adds a new entry to the hashtree
            </summary>
            <param name="key">key to add</param>
            <param name="value">value to add</param>
            <param name="updateDelegate">update delegate, by default will throw key already exits exception</param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.ContainsKey(`0)">
            <summary>
            Checks to see if a key is contained in the hashtable
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.TryGetValue(`0,`1@)">
            <summary>
            Try get value from hashtree
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.GetValueOrDefault(`0,`1)">
            <summary>
            Get value or default from hash tree
            </summary>
            <param name="key">key to use for looking up</param>
            <param name="defaultValue">default value if not found</param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.GetValueOrDefault(`0,System.Int32,`1)">
            <summary>
            Get value or default value from hash tree using a known hash value
            </summary>
            <param name="key">key to use for look up</param>
            <param name="keyHash">hash value for key</param>
            <param name="defaultValue">default value to return when not found</param>
            <returns></returns>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.Item(`0)">
            <summary>
            Locate value from hash table, throws exception if not found
            </summary>
            <param name="key">key for hash table</param>
            <returns></returns>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.Keys">
            <summary>
            Returns all the keys in the hashtree
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.Values">
            <summary>
            returns all the values in the hashtree
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.IsEmpty">
            <summary>
            Is the hash tree empty
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.GetEnumerator">
            <summary>
            Gets an enumerator for the immutable hash
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.Count">
            <summary>
            Gets the count of the immutable hashtree. Note its faster to do a lookup than to do a count
            If you want to test for emptyness use the IsEmpty property
            </summary>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableLinkedList">
            <summary>
            Static helper class for linked list
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList.ThreadSafeEmpty``1(Grace.Data.Immutable.ImmutableLinkedList{``0}@)">
            <summary>
            Empty an immutable linked list in a thread and return the list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">list to empty</param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList.ThreadSafeAdd``1(Grace.Data.Immutable.ImmutableLinkedList{``0}@,``0)">
            <summary>
            Add to a list in a thread safe manner
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList.ThreadSafeAddRange``1(Grace.Data.Immutable.ImmutableLinkedList{``0}@,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add a range to a list in a thread safe manner
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="values"></param>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList.From``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            creates a new immutable linked list from an enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">enumerable of T</param>
            <returns>new list</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList.Create``1(``0[])">
            <summary>
            Create a new immutable linked list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values">values to create list from</param>
            <returns></returns>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableLinkedList`1">
            <summary>
            Immutable linked list class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableLinkedList`1.Empty">
            <summary>
            Empty instance of list
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.#ctor(`0,Grace.Data.Immutable.ImmutableLinkedList{`0},System.Int32)">
            <summary>
            Default constructor
            </summary>
            <param name="value"></param>
            <param name="next"></param>
            <param name="count"></param>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableLinkedList`1.Value">
            <summary>
            For for link
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableLinkedList`1.Next">
            <summary>
            Next link in the list
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableLinkedList`1.Count">
            <summary>
            Count for list
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.Add(`0)">
            <summary>
            Add value to list
            </summary>
            <param name="value">value to add to list</param>
            <returns>new linked list</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add range to linked list
            </summary>
            <param name="range">range to add</param>
            <returns>new linked list</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.GetEnumerator">
            <summary>
            Get an enumerator for list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator for list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.Reverse">
            <summary>
            Reverse linked list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.Visit(System.Action{`0},System.Boolean)">
            <summary>
            Visit all values in list
            </summary>
            <param name="action">action to call</param>
            <param name="startAtEnd">start at the end of the linked list</param>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableLinkedList`1.Contains(`0)">
            <summary>
            Check if list contains value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableLinkedList`1.Item(System.Int32)">
            <summary>Gets the element at the specified index in the read-only list.</summary>
            <returns>The element at the specified index in the read-only list.</returns>
            <param name="index">The zero-based index of the element to get. </param>
        </member>
        <member name="T:Grace.Data.Immutable.KeyExistsException`1">
            <summary>
            Key already exists in ImmutableHashTree
            </summary>
        </member>
        <member name="T:Grace.Data.ReflectionService">
            <summary>
            Helper class for accessing values using reflection
            </summary>
        </member>
        <member name="T:Grace.Data.ReflectionService.PropertyDictionaryDelegate">
            <summary>
            Delegate for creating dictionaries from object properties
            </summary>
            <param name="instance"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Data.ReflectionService.ExecuteDelegateWithInjection">
            <summary>
            Delegate for executing a delegate injecting parameters
            </summary>
            <param name="scope"></param>
            <param name="context"></param>
            <param name="injectionContext"></param>
            <param name="delegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.GetFriendlyNameForType(System.Type,System.Boolean)">
            <summary>
            Method to get friendly version of a type name for display purposes
            </summary>
            <param name="type"></param>
            <param name="includeNamespace"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.CheckTypeIsBasedOnAnotherType(System.Type,System.Type)">
            <summary>
            Checks to see if checkType is based on baseType
            Both inheritance and interface implementation is considered
            </summary>
            <param name="checkType">check type</param>
            <param name="baseType">base type</param>
            <returns>true if check type is base type</returns>
        </member>
        <member name="T:Grace.Data.ReflectionService.PropertyCasing">
            <summary>
            Casing for property names
            </summary>
        </member>
        <member name="F:Grace.Data.ReflectionService.PropertyCasing.Lower">
            <summary>
            Lower case all properties 
            </summary>
        </member>
        <member name="F:Grace.Data.ReflectionService.PropertyCasing.Upper">
            <summary>
            Upper case all properties
            </summary>
        </member>
        <member name="F:Grace.Data.ReflectionService.PropertyCasing.Default">
            <summary>
            Default casing of property names
            </summary>
        </member>
        <member name="M:Grace.Data.ReflectionService.GetPropertiesFromObject(System.Object,Grace.Data.Immutable.ImmutableHashTree{System.String,System.Object},Grace.Data.ReflectionService.PropertyCasing)">
            <summary>
            Get dictionary of property values from an object
            </summary>
            <param name="annonymousObject">object to get properties from</param>
            <param name="values">collection to add to</param>
            <param name="casing">lowercase property names</param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.InjectAndExecuteDelegate(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,System.Delegate)">
            <summary>
            Execute delegate by injecting parameters then executing
            </summary>
            <param name="scope"></param>
            <param name="context"></param>
            <param name="injectionContext"></param>
            <param name="delegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.DependencyType">
            <summary>
            Dependency type
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.DependencyType.ConstructorParameter">
            <summary>
            for constructor parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.DependencyType.Property">
            <summary>
            Property
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.DependencyType.Field">
            <summary>
            Field
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.DependencyType.MethodParameter">
            <summary>
            Method parameter
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ActivationStrategyDependency">
            <summary>
            Represents a dependency needed for an activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ActivationStrategyDependency.#ctor(Grace.DependencyInjection.DependencyType,Grace.DependencyInjection.IActivationStrategy,System.Object,System.Type,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="dependencyType"></param>
            <param name="activationStrategy"></param>
            <param name="injectionInfo"></param>
            <param name="typeBeingImported"></param>
            <param name="memberName"></param>
            <param name="hasValueProvider"></param>
            <param name="hasFilter"></param>
            <param name="isSatisfied"></param>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.DependencyType">
            <summary>
            Dependency type 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.ActivationStrategy">
            <summary>
            Activation strategy the dependency belong to
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.InjectionInfo">
            <summary>
            The MemberInfo or ParameterInfo that's being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.TypeBeingImported">
            <summary>
            Type being imported
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.MemberName">
            <summary>
            Name of member being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.HasValueProvider">
            <summary>
            Has Value Provider
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.HasFilter">
            <summary>
            Has a filter for it's dependency
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ActivationStrategyDependency.IsSatisfied">
            <summary>
            Is the dependency satisified
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Arg">
            <summary>
            Arg helper
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Arg.Any``1">
            <summary>
            Any arguement of type T
            </summary>
            <typeparam name="T">type of arg</typeparam>
            <returns>default T value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Arg.Locate``1">
            <summary>
            Locate arguement of type T
            </summary>
            <typeparam name="T">type of arg</typeparam>
            <returns>default T value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Arg.Locate``1(System.Object)">
            <summary>
            Locate type and specify how to construct certain dependencies
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Arg.Scope">
            <summary>
            Get the current scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Arg.Context">
            <summary>
            Get the current context
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportAttribute">
            <summary>
            This attribute is used to mark a type for export. 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor(System.Type[])">
            <summary>
            Export by type rather than by name
            </summary>
            <param name="exportTypes"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ExportAttribute.ExportTypes">
            <summary>
            List of export types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute">
            <summary>
            Classes that have this attribute will be exported by the interfaces it implements
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provides a list of export types (i.e. implemented interfaces)
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportKeyedTypeAttribute">
            <summary>
            Adds a key to an exported class
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportKeyedTypeAttribute.#ctor(System.Type,System.Object)">
            <summary>
            Default constructor
            </summary>
            <param name="type">export type</param>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportKeyedTypeAttribute.ProvideKey(System.Type)">
            <summary>
            provide type and key for export
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportPriorityAttribute">
            <summary>
            This attribute can be used to control the priority for the export
            Note: ranked high to low
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Export priority cosntructor
            </summary>
            <param name="priority">priority for export, ranked high to low</param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportPriorityAttribute.ProvidePriority(System.Type)">
            <summary>
            Provide a priority value
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>priority value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute">
            <summary>
            Limits an export to only be used when the class it's being injected into has the specified attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default constructor that takes an attribute type to filter on
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide a condition for the type provided
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute">
            <summary>
            Applies an condition on the export where it will be injected into specified types and only those types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute.#ctor(System.Type[])">
            <summary>
            Default constructor takes list of injected types
            </summary>
            <param name="injectedTypes">types that this export can be used in</param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide a new WhenInjectedInto condition
            </summary>
            <param name="exportType">attributed type</param>
            <returns>new condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ImportAttribute">
            <summary>
            This attribute can be used to attribute properties, methods, constructors or parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Key">
            <summary>
            Key to use when importing 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Required">
            <summary>
            Is this import required. True by default
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ICustomInitializationAttribute">
            <summary>
            Attributes that implement this inteface will be used during discovery
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IEnrichWithAttribute">
            <summary>
            Attributes that implement will be called at discovery time to provide an EnrichWithDelegate
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute">
            <summary>
            Attributes that implement this interface will be included while scanning for exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute">
            <summary>
            Attributes that implement this interface can provide a condition for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportKeyedTypeAttribute">
            <summary>
            Attributes that implement this interface will be used to provide an export key
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportKeyedTypeAttribute.ProvideKey(System.Type)">
            <summary>
            Provide an export key
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>export key</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute">
            <summary>
            Attributes that implement this interface will be called during discovery to provide metadata for an attributed type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute.ProvideMetadata(System.Type)">
            <summary>
            Provide the metadata for an attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>a named piece of metadata</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute">
            <summary>
            Attributes that implement this interface will be called during discover to provide a priority
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute.ProvidePriority(System.Type)">
            <summary>
            Provide the priority for an attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute">
            <summary>
            Attributes that implement this interface will be called at discovery time to provide an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute.ProvideStrategy(System.Type)">
            <summary>
            Provide an export strategy for the attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo">
            <summary>
            Information about how the import should be performed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.DefaultValue">
            <summary>
            Default value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ImportKey">
            <summary>
            The key that should be used when importing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ExportStrategyFilter">
            <summary>
            Import Filter 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.Comparer">
            <summary>
            Comparer object for import
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute">
            <summary>
            Attributes that implement this interface will be included while discovering attributes for importing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ILifestyleProviderAttribute">
            <summary>
            Attributes that implement this interface will be queried during discovery to provide a life cycle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.ILifestyleProviderAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.MetadataAttribute">
            <summary>
            Attribute used to add metadata for attributed export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.MetadataAttribute.#ctor(System.Object,System.Object)">
            <summary>
            default constructor
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.MetadataAttribute.ProvideMetadata(System.Type)">
            <summary>
            Provide the metadata for an attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>a named piece of metadata</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonAttribute">
            <summary>
            Exports attribute with this attribute will be shared as a single instance for all scopes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerObjectGraphAttribute">
            <summary>
            Exports marked with this attribute will be shared per injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerObjectGraphAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute">
            <summary>
            Attribute for per request singleton
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute">
            <summary>
            Exports marked with this attribute will be shared per scope.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WeakSingletonAttribute">
            <summary>
            Exports attributed with this will be shared, the instance will be held with a weak reference so it will be GC'd when done
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WeakSingletonAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenClassHasAttribute">
            <summary>
            Export condition that limits the export to only be used in classes that have a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provides a new WhenClassHas condition
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute">
            <summary>
            Limits an export to only be used when being injected into one of the types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute">
            <summary>
            Limits an export to only be used when the importing member has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute">
            <summary>
            Limits an export to only be used when the target has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute.#ctor(System.Type)">
            <summary>
            Default constructor that takes attribute type
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.FuncCompiledCondition">
            <summary>
            Condition that calls a function to test if conditions are meet
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.FuncCompiledCondition.#ctor(System.Func{Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext,System.Boolean})">
            <summary>
            Default constructor takes condition function
            </summary>
            <param name="condition">condition function</param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.FuncCompiledCondition.MeetsCondition(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Test if condition is meet
            </summary>
            <param name="strategy">strategy to test</param>
            <param name="staticInjectionContext">static injection context</param>
            <returns>true if condition is meet</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.ICompiledCondition">
            <summary>
            used to test if an activation strategy should be used
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.ICompiledCondition.MeetsCondition(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Test if strategy meets condition at configuration time
            </summary>
            <param name="strategy">strategy to test</param>
            <param name="staticInjectionContext">static injection context</param>
            <returns>meets condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenClassHas">
            <summary>
            condition class for testing if target has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.#ctor(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.MeetsCondition(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Test if strategy meets condition
            </summary>
            <param name="strategy">strategy to test</param>
            <param name="staticInjectionContext">static injection context</param>
            <returns>meets condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenClassHas`1">
            <summary>
            condition class for testing if target has a particular attribute
            </summary>
            <typeparam name="TAttribute">attribute type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas`1.#ctor(System.Func{`0,System.Boolean})">
            <summary>
            Default constructor
            </summary>
            <param name="filter"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Conditions.WhenClassHas`1.IsRequestTimeCondition">
            <summary>
            Should the condition be run at expression creation time or every time a request is made for the type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Conditions.WhenClassHas`1.RequiresInjectionContext">
            <summary>
            If it is a request time condition does it need an injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas`1.MeetsCondition(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Test if strategy meets condition
            </summary>
            <param name="strategy">strategy to test</param>
            <param name="staticInjectionContext">static injection context</param>
            <returns>meets condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1">
            <summary>
            Class that allows the configuration of conditions
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.AddAction">
            <summary>
            Add action
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.TValue">
            <summary>
            TValue to return
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.#ctor(System.Action{Grace.DependencyInjection.Conditions.ICompiledCondition},`0)">
            <summary>
            Default constructor that takes action to add condition and T to return
            </summary>
            <param name="addAction">action to add condition</param>
            <param name="t">T to return</param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.MeetsCondition(Grace.DependencyInjection.Conditions.ICompiledCondition)">
            <summary>
            Adds a new compiled condition to the strategy
            </summary>
            <param name="condition">condition to add</param>
            <returns>T</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.MeetsCondition(System.Func{Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext,System.Boolean})">
            <summary>
            Adds a condition to strategy that is a function with the signature (strategy, staticContext)
            </summary>
            <param name="condition">test condition</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.TargetHas``1(System.Func{``0,System.Boolean})">
            <summary>
            Add a condition to use this export only when Target (parameter, property, method) has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.ClassHas(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Add a condition to use this export only when the class being injected into has a specific attribute
            </summary>
            <param name="attributeType"></param>
            <param name="testFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.ClassHas``1(System.Func{``0,System.Boolean})">
            <summary>
            Class being injected into has a specific attribute
            </summary>
            <param name="testFunc"></param>
            <typeparam name="TAttribute"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.MemberHas``1(System.Func{``0,System.Boolean})">
            <summary>
            Add a condition to use this export only when the member being injected into has a specific attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="testFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.InjectedInto``1">
            <summary>
            Use strategy when injected into a specific type
            </summary>
            <typeparam name="TInjectedType">injected type</typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.InjectedInto(System.Type[])">
            <summary>
            Use strategy when injected into a specific type
            </summary>
            <param name="types">types allowed to be injected into</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenConditionConfiguration`1.InjectedInto(System.Func{System.Type,System.Boolean})">
            <summary>
            
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenInjectedInto">
            <summary>
            Condition for testing if a strategy is being injected into another
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.#ctor(System.Type[])">
            <summary>
            Default constructor takes list of types
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.#ctor(System.Func{System.Type,System.Boolean})">
            <summary>
            Constructor that takes func to test with instead of array of types
            </summary>
            <param name="typeTest"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.MeetsCondition(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Test if being injected into a specific type
            </summary>
            <param name="strategy">strategy to test</param>
            <param name="staticInjectionContext">static injection context</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.TestTypes(System.Type,System.Type[])">
            <summary>
            Tests for if one type is based on another
            </summary>
            <param name="injectionType"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenMemberHas`1">
            <summary>
            Condition for if a member has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas`1.#ctor(System.Func{`0,System.Boolean})">
            <summary>
            Default constructor that takes a filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas`1.MeetsCondition(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Test if strategy meets condition
            </summary>
            <param name="strategy">strategy to test</param>
            <param name="staticInjectionContext">static injection context</param>
            <returns>meets condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenTargetHas">
            <summary>
            condition for when target has attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.#ctor(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.MeetsCondition(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Test if strategy meets condition
            </summary>
            <param name="strategy">strategy to test</param>
            <param name="staticInjectionContext">static injection context</param>
            <returns>meets condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ActivationStrategyDelegate">
            <summary>
            Delegate for activating a strategy
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionStrategyDelegate">
            <summary>
            Delegate for injecting value
            </summary>
            <param name="scope">injection scope</param>
            <param name="disposalScope">disposal scope</param>
            <param name="injectionContext">injection context</param>
            <param name="injectedInstance">instance to inject</param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyStaticFilter">
            <summary>
            Used to filter out exports at container configuration time
            </summary>
            <param name="staticContext"></param>
            <param name="strategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.ActivationStrategyFilter">
            <summary>
            Used to filter out exports
            </summary>
            <param name="strategy">strategy to filter</param>
            <returns>return true if the strategy should be used</returns>
        </member>
        <member name="T:Grace.DependencyInjection.KeyedLocateDelegate`2">
            <summary>
            This delegate will locate an export using a Key
            </summary>
            <typeparam name="TKey">key type to locate with</typeparam>
            <typeparam name="TValue">value type to locate</typeparam>
            <param name="key">key to locate with</param>
            <returns>located value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.DependencyInjectionContainer">
            <summary>
            Dependancy injection container, this is the main class to instantiate 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.#ctor(System.Action{Grace.DependencyInjection.InjectionScopeConfiguration})">
            <summary>
            Default constructor
            </summary>
            <param name="configuration">provide method to configure container behavior</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.#ctor(Grace.DependencyInjection.IInjectionScopeConfiguration)">
            <summary>
            Constructor requiring an injection scope configuration object be provided
            </summary>
            <param name="configuration">configuration object</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Add(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Add configuration module to container
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Add(System.Action{Grace.DependencyInjection.IExportRegistrationBlock})">
            <summary>
            Add registration delegate to container
            </summary>
            <param name="registrationAction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetEnumerator">
            <summary>
            This is here to allow adding configuration modules through object initialization. Always returns empty
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.ImportInjectionScopeException">
            <summary>
            This exception is thrown when trying to import IInjectionScope. Under most circumstances you want to inject IExportLocatorScope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Exceptions.ImportInjectionScopeException.ErrorMessage">
            <summary>
            Error message for exception
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.ImportInjectionScopeException.#ctor(Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Default constructor takes context
            </summary>
            <param name="context">static injection context</param>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.LocateException">
            <summary>
            Default locate exception for the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocateException.#ctor(Grace.DependencyInjection.StaticInjectionContext,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="context">static context required</param>
            <param name="message">message, this is not required</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocateException.#ctor(Grace.DependencyInjection.StaticInjectionContext,System.Exception,System.String)">
            <summary>
            Constructor that takes an inner exception
            </summary>
            <param name="context">static context</param>
            <param name="innerException">inner exception</param>
            <param name="message">message for exception</param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocateException.Context">
            <summary>
            Context information associated with the exception
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.NamedScopeLocateException">
            <summary>
            Exception thrown 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.NamedScopeLocateException.#ctor(System.String,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Default constructor
            </summary>
            <param name="scopeName">scope name</param>
            <param name="context">static injection context</param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.NamedScopeLocateException.ScopeName">
            <summary>
            Scope name that couldn't be found
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.NullValueProvidedException">
            <summary>
            Exception thrown when a null value is provided from a factory
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.NullValueProvidedException.#ctor(Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Default constructor
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.RecursiveLocateException">
            <summary>
            Exception thrown when a recursive loop is detected in the object graph
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.RecursiveLocateException.#ctor(Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Default constructor
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Grace.DependencyInjection.ConstructorSelectionMethod">
            <summary>
            Enumeration for constructor selection method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ConstructorSelectionMethod.BestMatch">
            <summary>
            Matches the best constructor based on which exports are registered
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ConstructorSelectionMethod.MostParameters">
            <summary>
            Use the constructor with the most parameters
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ConstructorSelectionMethod.LeastParameters">
            <summary>
            Use the constructor with the least parameters
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ConstructorSelectionMethod.Dynamic">
            <summary>
            Dynamicly pick the cosntructor to use each request, not very fast but allows for support similar to NInject
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IEnumerableCreator">
            <summary>
            Classes that implement this can be used to create enumerables
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IEnumerableCreator.CreateEnumerable``1(Grace.DependencyInjection.IExportLocatorScope,``0[])">
            <summary>
            Construct enumerable given a scope and an array
            </summary>
            <typeparam name="T">Type to enumerate</typeparam>
            <param name="scope">export locator scope</param>
            <param name="array">array to wrap as enumerable</param>
            <returns>enumerable</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportCompilationBehavior">
            <summary>
            Configure the how expressions are created
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ExportCompilationBehavior.DefaultKeyedTypeSelector(System.Type)">
            <summary>
            Default implementation for selecting types that should be located by key.
            Note: string, primitive and datetime are located by key
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.ExportCompilationBehavior.MaxObjectGraphDepth">
            <summary>
            Max object graph depth, this is what's used to detect a recursive loop
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.ExportCompilationBehavior.AllowInjectionScopeLocation">
            <summary>
            Allow IInjectionScope to be injected, false by default because you normally want IExportLocatorScope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportCompilationBehavior.ConstructorSelection">
            <summary>
            Constructor selection algorithm, best match by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportCompilationBehavior.CustomEnumerableCreator">
            <summary>
            customize IEnumerable&lt;T&gt; creation
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportCompilationBehavior.KeyedTypeSelector">
            <summary>
            Allows you to override the default behavior for what is located by key and what's not 
            Note: By default string, primitive and DateTime are true, everything else is false
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportCompilationBehavior.AllowInstanceAndFactoryToReturnNull">
            <summary>
            By default ExportInstance and ExportFactory must return a value. 
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Extensions.RegistrationBlockExtensions">
            <summary>
            C# registration block extensions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Extensions.RegistrationBlockExtensions.ExportFunc``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Func{Grace.DependencyInjection.IExportLocatorScope,``0})">
            <summary>
            Directly export a function with no decoratory, no testing for null, no lifestyle. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="block"></param>
            <param name="func"></param>
        </member>
        <member name="T:Grace.DependencyInjection.RequestType">
            <summary>
            Type of request (Root, Constructor parameter, etc)
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.RequestType.Root">
            <summary>
            Root of the object graph
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.RequestType.ConstructorParameter">
            <summary>
            for constructor parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.RequestType.Member">
            <summary>
            For member (field or property)
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.RequestType.MethodParameter">
            <summary>
            Method parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.RequestType.Other">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationPathNode">
            <summary>
            Activation node for wrapper or decorator path
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationPathNode.Strategy">
            <summary>
            Strategy to use when activating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationPathNode.ActivationType">
            <summary>
            Type the strategy satisfies
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationPathNode.Lifestyle">
            <summary>
            Lifestyle for activation node
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationPathNode.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get activation expression
            </summary>
            <param name="scope">scope for node</param>
            <param name="request">request for activation</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IKnownValueExpression">
            <summary>
            Known value expression
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IKnownValueExpression.ActivationType">
            <summary>
            Type for expression
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IKnownValueExpression.Key">
            <summary>
            Hint for locating when multiple
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IKnownValueExpression.Position">
            <summary>
            Hint for where the value should be positioned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IKnownValueExpression.ValueExpression(Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Expression that represents the known value
            </summary>
            <param name="request">request for expression</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IDefaultValueInformation">
            <summary>
            Default value information
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IDefaultValueInformation.DefaultValue">
            <summary>
            Default value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationServices">
            <summary>
            Services to be used during request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationServices.AttributeDiscoveryService">
            <summary>
            Service for locating attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationServices.Compiler">
            <summary>
            Service for compiling delegates
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationServices.ExpressionBuilder">
            <summary>
            Linq expression builder
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationServices.LifestyleExpressionBuilder">
            <summary>
            Expression builder that takes lifestyle into consideration
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationServices.InjectionContextCreator">
            <summary>
            Injection context creator
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExpressionConstants">
            <summary>
            Expression constants for request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExpressionConstants.RootDisposalScope">
            <summary>
            Root disposal scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExpressionConstants.ScopeParameter">
            <summary>
            export locator scope parameter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExpressionConstants.InjectionContextParameter">
            <summary>
            Injection context parameter
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IDataPerDelegate">
            <summary>
            Data that is per delegate, used for lifestyles
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationExpressionRequest">
            <summary>
            Request context to create expression
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.ActivationType">
            <summary>
            Type being requested
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.LocateKey">
            <summary>
            Key to use for locating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.InjectedType">
            <summary>
            Type being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.RequestingStrategy">
            <summary>
            Requesting strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.RequestType">
            <summary>
            Type of request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.Parent">
            <summary>
            Parent request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.Filter">
            <summary>
            Export strategy filter to use
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.EnumerableComparer">
            <summary>
            IComparer to be used when locating array or 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.Services">
            <summary>
            Services for request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.Constants">
            <summary>
            Constants for request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.IsRequired">
            <summary>
            Is request required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.DisposalScopeExpression">
            <summary>
            Disposal scope expression to use
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.ScopeParameter">
            <summary>
            export locator scope parameter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.InjectionContextParameter">
            <summary>
            Injection context parameter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.Info">
            <summary>
            Info object for request (MethodInfo, FieldInfo, ParameterInfo)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.ObjectGraphDepth">
            <summary>
            Current object graph depth
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.DecoratorPathNode">
            <summary>
            Current decorator path if decorating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.WrapperPathNode">
            <summary>
            Wrapper path if in the middel of wrapping
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.DefaultValue">
            <summary>
            Default value for request if not found
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.IsDynamic">
            <summary>
            Is the request dynamic
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.KnownValueExpressions">
            <summary>
            Known values that can be used in request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.PopWrapperPathNode">
            <summary>
            Pop wrapper node off path
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.PopDecoratorPathNode">
            <summary>
            Pop decorator node off path
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.SetFilter(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Set filter for this request
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.SetEnumerableComparer(System.Object)">
            <summary>
            Set the comparer for this request
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.SetDecoratorPath(Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.IActivationPathNode})">
            <summary>
            Set the decorator path for request
            </summary>
            <param name="path">node path</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.SetWrapperPath(Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.IActivationPathNode})">
            <summary>
            Set wrapper path for request
            </summary>
            <param name="wrappers">node path</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.GetWrappedStrategy">
            <summary>
            Get the currently wrapped strategy if one exists
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.SetIsRequired(System.Boolean)">
            <summary>
            Set is required value for request
            </summary>
            <param name="isRequired">is value required</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.SetLocateKey(System.Object)">
            <summary>
            Set key for request
            </summary>
            <param name="key">key to use for request</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.SetDefaultValue(Grace.DependencyInjection.IDefaultValueInformation)">
            <summary>
            Set default value for request
            </summary>
            <param name="defaultValue">default value</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.GetWrappedExportStrategy">
            <summary>
            Get wrapped strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.GetStaticInjectionContext">
            <summary>
            Get static injection context for request
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.CreateTargetInfo(Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.InjectionTargetInfo})">
            <summary>
            Create target info for request
            </summary>
            <param name="targetInfos">child targets</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.AddKnownValueExpression(Grace.DependencyInjection.IKnownValueExpression)">
            <summary>
            Add known value expression to request
            </summary>
            <param name="knownValueExpression">known value expression</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.RequireInjectionContext">
            <summary>
            Require injection context for request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.InjectionContextRequired">
            <summary>
            Is injection context required
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.NewRequest(System.Type,Grace.DependencyInjection.IActivationStrategy,System.Type,Grace.DependencyInjection.RequestType,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Create new request from this request
            </summary>
            <param name="activationType">request type</param>
            <param name="requestingStrategy">requesting strategy</param>
            <param name="injectedType">type being injected into</param>
            <param name="requestType">request type</param>
            <param name="info">info for request</param>
            <param name="maintainPaths">maintain wrapper and decorator path</param>
            <param name="carryData"></param>
            <returns>new request</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionRequest.NewRootedRequest(System.Type,Grace.DependencyInjection.IInjectionScope,System.Boolean)">
            <summary>
            Creates new rooted request (for lifestyles)
            </summary>
            <param name="activationType"></param>
            <param name="requestingScope"></param>
            <param name="maintainPaths"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.RequestingScope">
            <summary>
            Scope the request originated in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionRequest.PerDelegateData">
            <summary>
            Data that is per delegate and won't transfer to other delegates
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationExpressionResult">
            <summary>
            Represents an expression and can be used to create a delegate
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionResult.Request">
            <summary>
            Request that generated result
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionResult.Expression">
            <summary>
            Expression for result
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationExpressionResult.UsingFallbackExpression">
            <summary>
            True if no type was found and the default fallback expression was used
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionResult.AddExpressionResult(Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Add child expression result
            </summary>
            <param name="result">expression result</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionResult.AddExtraParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Add extra parameter for expression 
            </summary>
            <param name="parameter">parameter to declare</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionResult.ExtraParameters">
            <summary>
            Extra parameters for result
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionResult.AddExtraExpression(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Add extra expression to result 
            </summary>
            <param name="expression">expression for delegate</param>
            <param name="insertBeginning">by default expressions are added to the end, set this to true to insert at beginning</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationExpressionResult.ExtraExpressions">
            <summary>
            Extra expressions for result
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.ActivationStrategyType">
            <summary>
            Type of strategy, export, wrapper, or decorator
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ActivationStrategyType.ExportStrategy">
            <summary>
            Export
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ActivationStrategyType.FrameworkExportStrategy">
            <summary>
            Export from framework
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ActivationStrategyType.WrapperStrategy">
            <summary>
            Wrapper strategy
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ActivationStrategyType.DecoratorStrategy">
            <summary>
            Decorator strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationStrategy">
            <summary>
            Activation strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.InjectionScope">
            <summary>
            Injection scope for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.Priority">
            <summary>
            Priority
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.ActivationType">
            <summary>
            Type being activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.Lifestyle">
            <summary>
            Lifestyle for this activation stratgey
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.ExportAs">
            <summary>
            Export as a particular type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.ExportAsKeyed">
            <summary>
            Export as a keyed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.ExportAsName">
            <summary>
            Export as a name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.HasConditions">
            <summary>
            Does the activation strategy have conditions for it's use
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.Conditions">
            <summary>
            Conditions for this activation strategy to be used
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategy.GetActivationConfiguration(System.Type)">
            <summary>
            Get activation configuration for strategy
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategy.Metadata">
            <summary>
            Get the metadata for this activation strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategy.GetDependencies(Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Dependencies needed to activate strategy given a specific request
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationStrategyCollection`1">
            <summary>
            Represents a collection of activation strategies
            </summary>
            <typeparam name="T">strategy type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollection`1.AddStrategy(`0,System.Object)">
            <summary>
            Add a new strategy to collection
            </summary>
            <param name="strategy">strategy to add</param>
            <param name="key">key associated with type, can be null</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollection`1.GetPrimary">
            <summary>
            Get primary strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollection`1.GetStrategies">
            <summary>
            Strategies that are non keyed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollection`1.GetKeyedStrategies">
            <summary>
            list of strategies and their keys
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollection`1.GetKeyedStrategy(System.Object)">
            <summary>
            Get a keyed strategy
            </summary>
            <param name="key">key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollection`1.Clone">
            <summary>
            Clone the collection
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1">
            <summary>
            Represents a collection of strategy collections
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1.AddStrategy(`0)">
            <summary>
            Add strategy to container
            </summary>
            <param name="strategy">strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1.GetAllStrategies">
            <summary>
            Get all strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1.GetActivationStrategyCollection(System.Type)">
            <summary>
            Get collection for a specific type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1.GetActivationStrategyCollectionByName(System.String)">
            <summary>
            Get collection for a specific name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1.GetActivationTypes">
            <summary>
            Get all activation types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1.Clone">
            <summary>
            Clone the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCollectionContainer`1.AddInspector(Grace.DependencyInjection.IActivationStrategyInspector)">
            <summary>
            Add strategy inspector
            </summary>
            <param name="inspector">inspector</param>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationStrategyCompiler">
            <summary>
            Compiler to create ActivationStrategyDelegate delegates
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategyCompiler.MaxObjectGraphDepth">
            <summary>
            Max object graph depth
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCompiler.CreateNewRequest(System.Type,System.Int32,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Creates a new expression request
            </summary>
            <param name="activationType">activation type</param>
            <param name="objectGraphDepth">current object depth</param>
            <param name="requestingScope">requesting scope</param>
            <returns>request</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCompiler.CreateNewResult(Grace.DependencyInjection.IActivationExpressionRequest,System.Linq.Expressions.Expression)">
            <summary>
            Create a new expresion result
            </summary>
            <param name="request">request</param>
            <param name="expression">expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCompiler.FindDelegate(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,Grace.DependencyInjection.IInjectionContext,System.Boolean)">
            <summary>
            Find a delegate for a specific type
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <param name="consider"></param>
            <param name="key"></param>
            <param name="forMissingType"></param>
            <param name="checkForMissingType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCompiler.CompileDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Compile a delegate
            </summary>
            <param name="scope"></param>
            <param name="expressionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCompiler.CreateInjectionDelegate(Grace.DependencyInjection.IInjectionScope,System.Type)">
            <summary>
            Create injection delegate 
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyCompiler.ProcessMissingStrategyProviders(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Process missing strategy providers
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategyCompiler.DefaultStrategyExpressionBuilder">
            <summary>
            Default strategy expression builder
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationStrategyInspector">
            <summary>
            This interface allows the developer inspect all strategies as they are added
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyInspector.Inspect``1(``0)">
            <summary>
            Inspect the activation strategy
            </summary>
            <typeparam name="T"></typeparam>
            <param name="strategy"></param>
        </member>
        <member name="T:Grace.DependencyInjection.IActivationStrategyMetadata">
            <summary>
            Represents metadata that can be assigned to a activation strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategyMetadata.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategyMetadata.ExportAs">
            <summary>
            Exported as 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IActivationStrategyMetadata.ExportAsKeyed">
            <summary>
            Exported as keyed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IActivationStrategyMetadata.MetadataMatches(System.Object,System.Object)">
            <summary>
            Check to see if specific metadata matches
            </summary>
            <param name="key">key to use</param>
            <param name="value">value to compare</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.ICompiledDecoratorStrategy">
            <summary>
            Compiled decorator strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ICompiledDecoratorStrategy.ApplyAfterLifestyle">
            <summary>
            Apply the decorator after a lifestyle has been used
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ICompiledExportStrategy">
            <summary>
            Represents an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ICompiledExportStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.ICompiledExportStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ICompiledWrapperStrategy">
            <summary>
            Compiled wrapper 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ICompiledWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="type">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IConfigurableActivationStrategy">
            <summary>
            Configurable Activation Strategy 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.Priority">
            <summary>
            Priority for the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.Lifestyle">
            <summary>
            lifestyle associated with the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.DisposalDelegate">
            <summary>
            Disposal delegate for strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.AddExportAs(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="exportType">type to export as</param>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.AddExportAsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed type
            </summary>
            <param name="exportType">type to export as</param>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.AddExportAsName(System.String)">
            <summary>
            Export as name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.AddCondition(Grace.DependencyInjection.Conditions.ICompiledCondition)">
            <summary>
            Add condition for strategy
            </summary>
            <param name="condition">condition</param>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.MemberInjectionSelector(Grace.DependencyInjection.Impl.IMemberInjectionSelector)">
            <summary>
            Add member injection selector
            </summary>
            <param name="selector">member selector</param>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.MethodInjectionInfo(Grace.DependencyInjection.Impl.MethodInjectionInfo)">
            <summary>
            Add method injection info
            </summary>
            <param name="methodInjectionInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.EnrichmentDelegate(System.Object)">
            <summary>
            Delegate to enrich strategy with
            </summary>
            <param name="enrichmentDelegate">enrichment delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.ConstructorParameter(Grace.DependencyInjection.Impl.ConstructorParameterInfo)">
            <summary>
            Constructor parameter
            </summary>
            <param name="info"></param>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.SelectedConstructor">
            <summary>
            Constructor to use when creating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.ConstructorSelectionMethod">
            <summary>
            Constructor selection method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.ExternallyOwned">
            <summary>
            IS strategy externally owned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategy.SetMetadata(System.Object,System.Object)">
            <summary>
            Add metadata to strategy
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.ActivationMethod">
            <summary>
            Method that's called when the type is activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IConfigurableActivationStrategy.CustomScopeName">
            <summary>
            If not null then instance will be created in new scope.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IConfigurableActivationStrategyExtensions">
            <summary>
            C# extension class for configurable activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurableActivationStrategyExtensions.ProcessAttributeForStrategy(Grace.DependencyInjection.IConfigurableActivationStrategy)">
            <summary>
            Process attributes on type and configure strategy based on attributes
            </summary>
            <param name="strategy">strategy</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IConfigurationModule">
            <summary>
            Implement this interface to package registration together
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurationModule.Configure(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Configure the block
            </summary>
            <param name="registrationBlock">registration block</param>
        </member>
        <member name="T:Grace.DependencyInjection.IDecoratorOrExportActivationStrategy">
            <summary>
            Represents a decortator or an export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDecoratorOrExportActivationStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScope">
            <summary>
            Represents a scope that holds disposable object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.AddDisposable``1(``0)">
            <summary>
            Add an object for disposal tracking
            </summary>
            <param name="disposable">object to track for disposal</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.AddDisposable``1(``0,System.Action{``0})">
            <summary>
            Add an object for disposal tracking
            </summary>
            <param name="disposable">object to track for disposal</param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScopeProvider">
            <summary>
            Provides IDisposalScope for use during locate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScopeProvider.ProvideDisposalScope(Grace.DependencyInjection.IExportLocatorScope)">
            <summary>
            Provide a disposal scope for locator
            </summary>
            <param name="locatorScope">locator scope</param>
            <returns>new disposal scope</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocatorScope">
            <summary>
            Export locator scope represents a scope that can be located from InjectionScope and LifetimeScope implement this interface
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocatorScope.Parent">
            <summary>
            Parent scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocatorScope.ScopeId">
            <summary>
            Unique id for each scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocatorScope.ScopeName">
            <summary>
            Name of the scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorScope.GetLockObject(System.String)">
            <summary>
            Gets a named object that can be used for locking
            </summary>
            <param name="lockName">lock name</param>
            <returns>lock</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorScope.BeginLifetimeScope(System.String)">
            <summary>
            Create as a new IExportLocate scope
            </summary>
            <param name="scopeName">scope name</param>
            <returns>new scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorScope.CreateContext(System.Object)">
            <summary>
            Create injection context
            </summary>
            <param name="extraData">extra data</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocatorScopeExtensions">
            <summary>
            Extension class for IExportLocatorScope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorScopeExtensions.GetInjectionScope(Grace.DependencyInjection.IExportLocatorScope)">
            <summary>
            Get the parent injection scope for this export locator scope
            </summary>
            <param name="scope">export locator scope</param>
            <returns>parent injection scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorScopeExtensions.BeginLifetimeScope(Grace.DependencyInjection.IExportLocatorScope,System.String,System.Object)">
            <summary>
            Creates a new lifetime scope and sets extra data into it before returning
            </summary>
            <param name="scope">scope</param>
            <param name="scopeName">new scope name</param>
            <param name="extraData">extra data to add to scope</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorScopeExtensions.WhatDoIHave(Grace.DependencyInjection.IExportLocatorScope,System.Boolean,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            </summary>
            <param name="scope"></param>
            <param name="includeParent"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportRegistrationBlock">
            <summary>
            Represents a block of exports that will be registered
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddActivationStrategy(Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Add your own custom activation strategy
            </summary>
            <param name="activationStrategy">activation strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddExportStrategyProvider(Grace.DependencyInjection.Impl.IExportStrategyProvider)">
            <summary>
            Add your own strategy provider, usually used by 3rd party libraries to provide their own custom export types
            </summary>
            <param name="strategyProvider">strategy provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddInspector(Grace.DependencyInjection.IActivationStrategyInspector)">
            <summary>
            Add injection inspector that will be called to inspect all exports, wrappers and decorators (apply cross cutting configuration with an inspector)
            </summary>
            <param name="inspector">inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddMissingExportStrategyProvider(Grace.DependencyInjection.IMissingExportStrategyProvider)">
            <summary>
            Add missing export strategy provider
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddInjectionValueProvider(Grace.DependencyInjection.IInjectionValueProvider)">
            <summary>
            Add IInjectionValueProvider allowing the developer to override the normal behavior for creating an injection value
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddMemberInjectionSelector(Grace.DependencyInjection.Impl.IMemberInjectionSelector)">
            <summary>
            Add IMemberInjectionSelctor that selects 
            </summary>
            <param name="selector"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddModule(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Add configuration module
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export``1">
            <summary>
            Export a specific type
            </summary>
            <typeparam name="T">type to export</typeparam>
            <returns>export configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Type)">
            <summary>
            Export a specific type (open generics allowed)
            </summary>
            <param name="type">type to export</param>
            <returns>export configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Export a set of types
            </summary>
            <param name="types">types to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportDecorator(System.Type)">
            <summary>
            Export a type that will be used as a decorator for exports
            </summary>
            <param name="type">decorator type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportDecorator``1(System.Func{``0,``0},System.Boolean)">
            <summary>
            Export a piece of logic that will be used to decorate exports upon creation
            </summary>
            <typeparam name="T">type to decorate</typeparam>
            <param name="apply">decorator logic</param>
            <param name="applyAfterLifestyle"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportExpression``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Export an expression tree
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFactory``1(System.Func{``0})">
            <summary>
            Export a specific type
            </summary>
            <typeparam name="TResult">exported type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFactory``2(System.Func{``0,``1})">
            <summary>
            Export a specific type that requires some dependency
            </summary>
            <typeparam name="TIn">dependency type</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export function</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFactory``3(System.Func{``0,``1,``2})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFactory``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="T3">dependency three</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFactory``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="T3">dependency three</typeparam>
            <typeparam name="T4">dependency four</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFactory``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="T3">dependency three</typeparam>
            <typeparam name="T4">dependency four</typeparam>
            <typeparam name="T5">dependency five</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export a specific value
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instance">instance to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(System.Func{``0})">
            <summary>
            Export a specific type using a function
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">function to create instance</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,``0})">
            <summary>
            Export a specific type using an IExportLocatorScope
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">instance func</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,``0})">
            <summary>
            Export a specific type using IExportLocatorScope and StaticInjectionContext
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">isntance func</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Export a specific type using IExportLocatorScope, StaticInjectionContext and IInjectionContext
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">isntance func</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportWrapper(System.Type)">
            <summary>
            Export a type to be used as a wrapper rather than export (types like Func(), Owned, Meta are wrapper types)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.IsExported(System.Type,System.Object,Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Test if a type is exported
            </summary>
            <param name="type"></param>
            <param name="key"></param>
            <param name="excludeStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ClearExports(System.Func{Grace.DependencyInjection.ICompiledExportStrategy,System.Boolean})">
            <summary>
            Clears exports from registration block
            </summary>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportRegistrationBlockExtensions">
            <summary>
            C# extension class for IExportRegistrationBlock
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.PrioritizePartiallyClosedGenerics(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Ups the priority of partially closed generics based on the number of closed parameters
            </summary>
            <param name="registrationBlock">registration block</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportAssembly(Grace.DependencyInjection.IExportRegistrationBlock,System.Reflection.Assembly)">
            <summary>
            Export types from an assembly
            </summary>
            <param name="registrationBlock"></param>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportAssemblyContaining``1(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Export all types from an assembly comtaining a specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registrationBlock"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportAssemblies(Grace.DependencyInjection.IExportRegistrationBlock,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Export types from a set of assemblies
            </summary>
            <param name="registrationBlock"></param>
            <param name="assemblies">assemblies to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportAs``2(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Export a particular type as a particular interface
            </summary>
            <typeparam name="T">Type to export</typeparam>
            <typeparam name="TInterface">type to export as</typeparam>
            <param name="registrationBlock"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportTo(System.Collections.Generic.IEnumerable{System.Type},Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Extension to export a list of types to a registration block
            </summary>
            <param name="types">list of types</param>
            <param name="registrationBlock">registration block</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportNamedValue``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            This is a short cut to registering a value as a name using the member name for exporting
            ExportNamedValue(() => someValue) export the value of someValue under the name someValue
            ExportInstance(someValue).AsKeyed(someValue.GetType(), "someValue") is the long hand form
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registrationBlock"></param>
            <param name="valueExpression"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ImportMember``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Func{System.Reflection.MemberInfo,System.Boolean})">
            <summary>
            Import all members of a specific type and can be filtered
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registrationBlock"></param>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ImportMembers``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Import all members of a specific type and can be filtered
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registrationBlock"></param>
            <param name="filter">filter out members to inject</param>
            <param name="processAttributes">process import attribute</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ImportMembers(Grace.DependencyInjection.IExportRegistrationBlock,System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean,System.Boolean)">
            <summary>
            Import all members of a specific type and can be filtered
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registrationBlock"></param>
            <param name="filter"></param>
            <param name="injectMethods">should methods be injected, false by default</param>
            <param name="processAttributes">process import attribute</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportFuncWithContext``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Export func with context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="block"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.IfNotRegistered``1(Grace.DependencyInjection.IFluentExportInstanceConfiguration{``0},System.Type,System.Object)">
            <summary>
            Export only if type is not exported
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configuration"></param>
            <param name="type"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.IfNotRegistered(Grace.DependencyInjection.IFluentExportStrategyConfiguration,System.Type,System.Object)">
            <summary>
            Export only if type is not exported
            </summary>
            <param name="configuration"></param>
            <param name="type"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.IfNotRegistered``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0},System.Type,System.Object)">
            <summary>
            Export only if type is not exported
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configuration"></param>
            <param name="type"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExcludeTypeFromAutoRegistration(Grace.DependencyInjection.IExportRegistrationBlock,System.String)">
            <summary>
            Excludes type from auto registration based on name. * at the front or back of name will be treated as wildcard
            </summary>
            <param name="block"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExcludeTypeFromAutoRegistration(Grace.DependencyInjection.IExportRegistrationBlock,System.Type)">
            <summary>
            Excludes a type from being auto regsitered
            </summary>
            <param name="block"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportInitialize``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Action{``0})">
            <summary>
            Initialize all instance of a specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="block"></param>
            <param name="initializeAction"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetConfiguration">
            <summary>
            Interface for configuring a set of exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndCondition(System.Func{System.Type,System.Collections.Generic.IEnumerable{Grace.DependencyInjection.Conditions.ICompiledCondition}})">
            <summary>
            Add conditions for export
            </summary>
            <param name="conditions"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.BasedOn(System.Type)">
            <summary>
            Export all types based on speficied type by Type
            </summary>
            <param name="baseType">base type to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.BasedOn``1">
            <summary>
            Export all types based on speficied type by Type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterface``1">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="whereClause">where clause to test if the interface should be used for exporting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByName(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            Export by name
            </summary>
            <param name="nameFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByType">
            <summary>
            Export the selected classes by type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Exports by a set of types
            </summary>
            <param name="typeDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByKeyedTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Tuple{System.Type,System.Object}}})">
            <summary>
            Export a type by a set of keyed types
            </summary>
            <param name="keyedDelegate">keyed types</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude">exclude delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export types using their attributes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExternallyOwned">
            <summary>
            Mark all types as externally owned
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ImportConstructorSelection(System.Func{System.Type,Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator})">
            <summary>
            Set constructor selection method for individual exports
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IExportTypeSetConfiguration.Lifestyle">
            <summary>
            Lifestyle for set
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Set a particular life style
            </summary>
            <param name="container">lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.UsingLifestyle(System.Func{System.Type,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle})">
            <summary>
            Set a particular life style using a func
            </summary>
            <param name="lifestyleFunc">pick a lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.IExportTypeSetConfiguration.When">
            <summary>
            Add condition to exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Where(System.Func{System.Type,System.Boolean})">
            <summary>
            Export only types that match the filter provided
            </summary>
            <param name="typeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithInspector(Grace.DependencyInjection.IActivationStrategyInspector)">
            <summary>
            Add inspector for type set
            </summary>
            <param name="inspector"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions">
            <summary>
            extension methods for type set configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.PrioritizePartiallyClosedGenerics(Grace.DependencyInjection.IExportTypeSetConfiguration)">
            <summary>
            Ups the priority of partially closed generics based on the number of closed parameters
            </summary>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration">
            <summary>
            Configuration interface for decorator strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.ApplyAfterLifestyle">
            <summary>
            Apply decorator after lifestyle, by default it's before
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.As(System.Type)">
            <summary>
            Export as particular types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.When">
            <summary>
            Condition for decorator strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.WithCtorParam``2(System.Func{``0,``1})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.WithCtorParam``3(System.Func{``0,``1,``2})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.WithCtorParam``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.WithCtorParam``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration.WithCtorParam``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <typeparam name="TArg5"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1">
            <summary>
            cconfigure decorator parameter
            </summary>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filter">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.DefaultValue(`0)">
            <summary>
            Assign a default value if no better option is found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.DefaultValue(System.Func{`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.DefaultValue(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.IsDynamic(System.Boolean)">
            <summary>
            Mark the parameter as dynamic
            </summary>
            <param name="isDynamic"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.Named(System.String)">
            <summary>
            Name of the parameter being configured
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentDecoratorWithCtorConfiguration`1.Use(System.Type)">
            <summary>
            Use a specific type for parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1">
            <summary>
            Configuration interface for export instance
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as specific type
            </summary>
            <param name="type">type to export as</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed interface
            </summary>
            <param name="type">export type</param>
            <param name="key">export key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type
            </summary>
            <typeparam name="TInterface">type to export as</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsKeyed``1(System.Object)">
            <summary>
            Export as a specific keyed type
            </summary>
            <typeparam name="TExportType">type to export as</typeparam>
            <param name="key">key to export as</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export as specific name
            </summary>
            <param name="name">export name</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.ExternallyOwned">
            <summary>
            Mark an export as externally owned means the container will not track and dispose the instance
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.Lifestyle">
            <summary>
            Assign a lifestyle to this export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Only export if delegate returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Export using a specific lifestyle
            </summary>
            <param name="lifestyle">lifestlye to use</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.When">
            <summary>
            Use export under specific conditions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Set priority for export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportMemberConfiguration`1">
            <summary>
            Interface for configuring exporting a member
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportMemberConfiguration`1.WithType(System.Type)">
            <summary>
            Control what type the member is exported as
            </summary>
            <param name="exportType">export type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportMemberConfiguration`1.WithCondition(Grace.DependencyInjection.Conditions.ICompiledCondition)">
            <summary>
            Add a condition for property export
            </summary>
            <param name="condition">condition to add</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration">
            <summary>
            Interface for configuring a non generic type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type">type to export as</param>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed interface
            </summary>
            <param name="type">type to export as</param>
            <param name="key">key to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export as Name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export by interfaces
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned so the container does not track for disposal
            </summary>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Use specific constructor for use
            </summary>
            <param name="constructorInfo">constructor to use</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportConstructorSelection(Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator)">
            <summary>
            Specify the constructor selection algorithm
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportMembers(System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Import public members Fields, Properties, and Methods (not done by default) 
            </summary>
            <param name="selector">selector method, can be null</param>
            <param name="includeMethods">import all public methods that have parameters, false by default</param>
            <returns>configuraiton object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportStrategyConfiguration.Lifestyle">
            <summary>
            Apply a lifestlye to export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Export only if function returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Assign a custom lifestyle to an export
            </summary>
            <param name="lifestyle"></param>
            <returns>configuraiton object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportStrategyConfiguration.When">
            <summary>
            Apply a condition on when to use strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Configure constructor parameter
            </summary>
            <typeparam name="TParam"></typeparam>
            <param name="paramFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithMetadata(System.Object,System.Object)">
            <summary>
            Export with specific metadata
            </summary>
            <param name="key">metadata key</param>
            <param name="value">metadata value</param>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Set the priority for the export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.DefinesNamedScope(System.String)">
            <summary>
            Defines a custom scope when creating instance
            </summary>
            <param name="customscope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1">
            <summary>
            Represents a class that configures an export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.Apply(System.Action{`0})">
            <summary>
            Apply an action to the export just after construction
            </summary>
            <param name="applyAction">action to apply to export upon construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type">type to export as</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a particular type
            </summary>
            <typeparam name="TInterface">type to export as</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed type
            </summary>
            <param name="type">export type</param>
            <param name="key">key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsKeyed``1(System.Object)">
            <summary>
            Export as a keyed type
            </summary>
            <typeparam name="TInterface">export type</typeparam>
            <param name="key">key to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export as specific name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.DefinesNamedScope(System.String)">
            <summary>
            Creates a new scope and then resolves decorators inside of it.
            </summary>
            <param name="namedScope"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.DisposalCleanupDelegate(System.Action{`0})">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate">action to call when disposing</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.EnrichWithDelegate(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,`0,`0})">
            <summary>
            Enrich with delegate
            </summary>
            <param name="enrichmentDelegate">enrichment delegate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExportMember``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Export a public member of the type (property, field or method with return value)
            </summary>
            <typeparam name="TValue">type to export</typeparam>
            <param name="memberExpression">member expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExternallyOwned">
            <summary>
            Mark an export as externally owned means the container will not track and dispose the instance
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Func{`0}})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Use specific constructor for use
            </summary>
            <param name="constructorInfo">constructor to use</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportConstructorSelection(Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator)">
            <summary>
            Use a specific constructor selection method
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportMembers(System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Mark specific members to be injected
            </summary>
            <param name="selector">select specific members, if null all public members will be injected</param>
            <param name="injectMethod"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Import a specific property
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property">property expression</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Import a specific method on the type
            </summary>
            <param name="method">method to import</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.Lifestyle">
            <summary>
            Assign a lifestyle to this export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Export only if function returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Export using a specific lifestyle
            </summary>
            <param name="lifestyle">lifestlye to use</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.When">
            <summary>
            Add a condition to when this export can be used
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorCollectionParam``2">
            <summary>
            Import a collection allowing you to specify a filter and a sort order
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``2(System.Func{``0,``1})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``3(System.Func{``0,``1,``2})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <typeparam name="TArg5"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithMetadata(System.Object,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="key">metadata key</param>
            <param name="value">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Set the priority for the export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtentions">
            <summary>
            Extension methods for export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtentions.AutoWireProperties(Grace.DependencyInjection.IFluentExportStrategyConfiguration,System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            auto wire properties
            </summary>
            <param name="configuration"></param>
            <param name="propertyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtentions.AutoWireProperties``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0},System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configuration"></param>
            <param name="propertyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtentions.WithNamedCtorValue``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            This is intended to be a short cut for setting named property values
            The expression will be inspected and the value will used by the property name
            WithNameCtorValue(() => someLocalVariable) will export the value under the name someLocalVariable
            WithCtorParam(() => someLocalVariable).Named("someLocalVariable") is the long hand form
            </summary>
            <typeparam name="TValue">value type being used</typeparam>
            <param name="strategy">export strategy</param>
            <param name="valueExpression">value expression, the name of the parameter will be used as the parameter name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtentions.WithNamedCtorValue``2(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0},System.Linq.Expressions.Expression{System.Func{``1}})">
            <summary>
            This is intended to be a short cut for setting named property values
            The expression will be inspected and the value will used by the property name
            WithNameCtorValue(() => someLocalVariable) will export the value under the name someLocalVariable
            </summary>
            <typeparam name="T">Type being exported</typeparam>
            <typeparam name="TValue">value type being used</typeparam>
            <param name="strategy">export strategy</param>
            <param name="valueExpression">value expression, the name of the parameter will be used as the parameter name</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2">
            <summary>
            configuration for importing a property
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TProp"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            use a filter delegate when importing property
            </summary>
            <param name="consider">filter delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.DefaultValue(`1)">
            <summary>
            Default value if one can not be found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the property required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2">
            <summary>
            Configuration object for an imoprt collection
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.Named(System.String)">
            <summary>
            Parameter name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.SortBy(System.Collections.Generic.IComparer{`1})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.SortByProperty(System.Func{`1,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorConfiguration`1">
            <summary>
            configure constructor parameter
            </summary>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filter">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.DefaultValue(`0)">
            <summary>
            Assign a default value if no better option is found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.DefaultValue(System.Func{`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.DefaultValue(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.IsDynamic(System.Boolean)">
            <summary>
            Mark the parameter as dynamic
            </summary>
            <param name="isDynamic"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.Named(System.String)">
            <summary>
            Name of the parameter being configured
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.Use(System.Type)">
            <summary>
            Use a specific type for parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorConfiguration`2">
            <summary>
            configure constructor parameter
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filter">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.DefaultValue(`1)">
            <summary>
            Assign a default value if no better option is found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.DefaultValue(System.Func{`1})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.DefaultValue(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,`1})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.IsDynamic(System.Boolean)">
            <summary>
            Mark the parameter as dynamic (will be located from child scopes)
            </summary>
            <param name="isDynamic"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.Named(System.String)">
            <summary>
            Name of the parameter being configured
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`2.Use(System.Type)">
            <summary>
            Use specific type to satisfy parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWrapperStrategyConfiguration">
            <summary>
            Configuration object for wrapper strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWrapperStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentWrapperStrategyConfiguration.When">
            <summary>
            Apply a condition on when to use strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWrapperStrategyConfiguration.WrappedType(System.Type)">
            <summary>
            Set the type that is being wrapped
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWrapperStrategyConfiguration.WrappedGenericArg(System.Int32)">
            <summary>
            set the position of the generic arg being wrapped
            </summary>
            <param name="genericArgPosition"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionContext">
            <summary>
            Context that can be created for each request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.SharedData">
            <summary>
            Data container that is shared between all context for an object graph
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.ExtraData">
            <summary>
            Original object that was passed in as extra data when locate was called
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.GetValueByType(System.Type)">
            <summary>
            Get a value by type from the extra data
            </summary>
            <param name="type">type to locate</param>
            <returns>instance or null if one can't be found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Clone">
            <summary>
            Clone the extra data provider
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionContextSharedData">
            <summary>
            Data object that is shared between the root context and children contexts for a request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContextSharedData.GetLockObject(System.String)">
            <summary>
            Get a lock object by a specific name
            </summary>
            <param name="lockName"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionScope">
            <summary>
            Injection scope abstraction
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.Configure(System.Action{Grace.DependencyInjection.IExportRegistrationBlock})">
            <summary>
            Configure the injection scope
            </summary>
            <param name="registrationBlock"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Configure with module
            </summary>
            <param name="module">configuration module</param>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ScopeConfiguration">
            <summary>
            Scope configuration
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.StrategyCollectionContainer">
            <summary>
            Strategies associated with this scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.WrapperCollectionContainer">
            <summary>
            Wrappers associated with this scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.DecoratorCollectionContainer">
            <summary>
            Decorators associated with this scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.MemberInjectionSelectors">
            <summary>
            Member
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.MissingExportStrategyProviders">
            <summary>
            List of missing export strategy providers
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.InjectionValueProviders">
            <summary>
            List of value providers that can be used during construction of linq expression
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.LocateFromChildScope(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Locate an export from a child scope (for internal use)
            </summary>
            <param name="childScope">scope where the locate originated</param>
            <param name="disposalScope">disposal scope to use</param>
            <param name="type">type to locate</param>
            <param name="extraData">extra data passed in</param>
            <param name="consider">filter for strategies</param>
            <param name="key">key to use during locate</param>
            <param name="allowNull">allow null to be returned</param>
            <param name="isDynamic">is the lookup dynamic</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.LocateByNameFromChildScope(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Boolean)">
            <summary>
            
            </summary>
            <param name="childScope"></param>
            <param name="disposalScope"></param>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="allowNull"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.InternalLocateAll``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Internal locate all method
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="type"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.InternalLocateAllByName(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="exportName"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.CreateChildScope(System.Action{Grace.DependencyInjection.IExportRegistrationBlock},System.String)">
            <summary>
            Creates a new child scope
            This is best used for long term usage, not per request scenario
            </summary>
            <param name="configure">configure scope</param>
            <param name="scopeName">scope name </param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.StrategyCompiler">
            <summary>
            Strategy compiler used for this scope
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionScopeConfiguration">
            <summary>
            Represents a configuration information needed to construct an injection scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScopeConfiguration.SetInjectionScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            internal method used by the container
            </summary>
            <param name="scope">owning scope</param>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.Implementation">
            <summary>
            This the containers internal DI container. If you want to change any implementation you would add them here
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.Behaviors">
            <summary>
            Allows you to configure how to construct compiled exports.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.CatchDisposalExceptions">
            <summary>
            Catch exceptions on disposal, false by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.CacheArraySize">
            <summary>
            Size of the array used to cache execution delegates. By default it's 64, if you wish to change this make sure it's a power of 2
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.ExportStrategyArraySize">
            <summary>
            Size of array used to cache export strategies. By default it's 16, if you wish to change this make sure it's a power of 2
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.AutoRegisterUnknown">
            <summary>
            Register concrete implementation that are unknown
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.AutoRegistrationLifestylePicker">
            <summary>
            Lifestyle picker to be used when 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.ExportAsBase">
            <summary>
            Export as type and base implementations, true by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.DisposalScopeProvider">
            <summary>
            Override which disposal scope is used for tracking disposables, null by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.ExportByInterfaceFilter">
            <summary>
            Function that filters out interface types.
            First type arg is interface, second type arg is implementing, return true if should filter out
            Note: by default IDisposable and _Attribute are filter out
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.SupportFuncType">
            <summary>
            Support Func&lt;Type,object&gt; out of the box
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.Trace">
            <summary>
            Method that can be called to trace the container
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.TrackDisposableTransients">
            <summary>
            Should the container track disposable transients
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScopeConfiguration.InjectIDisposable">
            <summary>
            Inject current disposal scope as IDisposable
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScopeConfiguration.Clone">
            <summary>
            Clone configuration
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionValueProvider">
            <summary>
            Interface to provide expression for when a request is made
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionValueProvider.CanLocate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
             Can a value be located for this request
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionValueProvider.GetExpressionResult(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an expression for the request, returns null if this provider doesn't support it
            </summary>
            <param name="scope">scope for request</param>
            <param name="request">request for expression</param>
            <returns>expression result</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ILifetimeScopeProvider">
            <summary>
            Interface for providing IExportLocatorScope instances
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ILifetimeScopeProvider.CreateScope(Grace.DependencyInjection.IExportLocatorScope,System.String,Grace.Data.Immutable.ImmutableHashTree{System.Type,Grace.DependencyInjection.ActivationStrategyDelegate}[])">
            <summary>
            Create new scope 
            </summary>
            <param name="parentScope"></param>
            <param name="scopeName"></param>
            <param name="activationStrategyDelegates"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.ILocatorService">
            <summary>
            Represents a class that can locate types, classes should not implement this interface directly rather IExportLocatorScope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.CanLocate(System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object)">
            <summary>
            Can Locator type
            </summary>
            <param name="type">type to locate</param>
            <param name="consider"></param>
            <param name="key">key to use while locating</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.Locate(System.Type)">
            <summary>
            Locate a specific type
            </summary>
            <param name="type">type to locate</param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.LocateOrDefault(System.Type,System.Object)">
            <summary>
            Locate type or return default value
            </summary>
            <param name="type"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.Locate``1">
            <summary>
            Locate type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.LocateOrDefault``1(``0)">
            <summary>
            Locate or return default
            </summary>
            <typeparam name="T"></typeparam>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.Locate(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Locate specific type using extra data or key
            </summary>
            <param name="type">type to locate</param>
            <param name="extraData">extra data to be used during construction</param>
            <param name="consider">strategy filter</param>
            <param name="withKey">key to use for locating type</param>
            <param name="isDynamic"></param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.Locate``1(System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Locate specific type using extra data or key
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="extraData">extra data</param>
            <param name="consider"></param>
            <param name="withKey">key to use during construction</param>
            <param name="isDynamic"></param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.LocateAll(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate all instances of a specific type
            </summary>
            <param name="type">type ot locate</param>
            <param name="extraData">extra data to be used while locating</param>
            <param name="consider">strategy filter</param>
            <param name="comparer">comparer to use to sort collection</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.LocateAll``1(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all of a specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type">type to locate, can be null</param>
            <param name="extraData">extra data to use during locate</param>
            <param name="consider"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.TryLocate``1(``0@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Try to locate an export by type
            </summary>
            <typeparam name="T">locate type</typeparam>
            <param name="value">out value</param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="withKey"></param>
            <param name="isDynamic"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.TryLocate(System.Type,System.Object@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            try to locate a specific type
            </summary>
            <param name="type">type to locate</param>
            <param name="value">located value</param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="withKey"></param>
            <param name="isDynamic"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.LocateByName(System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Locate by name
            </summary>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.LocateAllByName(System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Locate all by specific name
            </summary>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ILocatorService.TryLocateByName(System.String,System.Object@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Try to locate by name
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IMissingExportStrategyProvider">
            <summary>
            Provide activation strategies for a missing type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IMissingExportStrategyProvider.CanLocate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Can a given request be located using this provider
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IMissingExportStrategyProvider.ProvideExports(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Provide exports for a missing type
            </summary>
            <param name="scope">scope to provide value</param>
            <param name="request">request</param>
            <returns>set of activation strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IActivationStrategyAttributeProcessor">
            <summary>
            Process attributes on activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyAttributeProcessor.ProcessAttributeForConfigurableActivationStrategy(Grace.DependencyInjection.IConfigurableActivationStrategy)">
            <summary>
            Process attribute on strategy
            </summary>
            <param name="strategy">activation strategy</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ActivationStrategyAttributeProcessor">
            <summary>
            Process attributes on strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyAttributeProcessor.ProcessAttributeForConfigurableActivationStrategy(Grace.DependencyInjection.IConfigurableActivationStrategy)">
            <summary>
            Process attribute on strategy
            </summary>
            <param name="strategy">activation strategy</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1">
            <summary>
            holds a set of activation strategies
            </summary>
            <typeparam name="T">type of activation strategy</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.AddStrategy(`0,System.Object)">
            <summary>
            Add a new strategy to collection
            </summary>
            <param name="strategy">strategy to add</param>
            <param name="key">key associated with type, can be null</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.GetStrategies">
            <summary>
            Strategies that are non keyed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.GetPrimary">
            <summary>
            Get primary strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.GetKeyedStrategies">
            <summary>
            list of strategies and their keys
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.GetKeyedStrategy(System.Object)">
            <summary>
            Get a keyed strategy
            </summary>
            <param name="key">key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.Clone">
            <summary>
            Clone the collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollection`1.Dispose">
            <summary>
            Dispose of collection
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1">
            <summary>
            Container of activation strategy collection
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="arraySize"></param>
            <param name="exportAsBase"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.#ctor(Grace.Data.Immutable.ImmutableHashTree{System.Type,Grace.DependencyInjection.IActivationStrategyCollection{`0}}[])">
            <summary>
            Protected constructor to be used internally
            </summary>
            <param name="collections"></param>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.ExportAsBase">
            <summary>
            Export type as their base
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.ArrayLengthMinusOne">
            <summary>
            Array length of Collections minus one 
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.Collections">
            <summary>
            Array of hash trees
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.Inspectors">
            <summary>
            Inspectors to apply to strategies
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.StrategiesByName">
            <summary>
            Strategies by name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.AddStrategy(`0)">
            <summary>
            Add strategy to container
            </summary>
            <param name="strategy">strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.GetAllStrategies">
            <summary>
            Get all strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.GetActivationStrategyCollection(System.Type)">
            <summary>
            Get collection for a specific type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.GetActivationStrategyCollectionByName(System.String)">
            <summary>
            Get collection for a specific name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.GetActivationTypes">
            <summary>
            Get all activation types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.Clone">
            <summary>
            Clone the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.AddInspector(Grace.DependencyInjection.IActivationStrategyInspector)">
            <summary>
            Add strategy inspector
            </summary>
            <param name="inspector">inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.CreateCollection(System.Type)">
            <summary>
            Create a collection of activation strategy
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCollectionContainer`1.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ActivationStrategyCompiler">
            <summary>
            Locates and compiles activation strategies for
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.#ctor(Grace.DependencyInjection.IInjectionScopeConfiguration,Grace.DependencyInjection.Impl.Expressions.IActivationExpressionBuilder,Grace.DependencyInjection.Impl.IAttributeDiscoveryService,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IExpressionConstants,Grace.DependencyInjection.Impl.IInjectionStrategyDelegateCreator)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration">scope configuration</param>
            <param name="builder">activation expression builder</param>
            <param name="attributeDiscoveryService">attribute discovery service</param>
            <param name="exportExpressionBuilder">expression builder</param>
            <param name="injectionContextCreator">injection context creator</param>
            <param name="constants">expression constants</param>
            <param name="injectionStrategyDelegateCreator">injection strategy creator</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.MaxObjectGraphDepth">
            <summary>
            Max object graph depth
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.DefaultStrategyExpressionBuilder">
            <summary>
            Default strategy expression builder
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.CreateNewRequest(System.Type,System.Int32,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Creates a new expression request
            </summary>
            <param name="activationType">activation type</param>
            <param name="objectGraphDepth">current object depth</param>
            <param name="requestingScope">requesting scope</param>
            <returns>request</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.CreateNewResult(Grace.DependencyInjection.IActivationExpressionRequest,System.Linq.Expressions.Expression)">
            <summary>
            Create a new expresion result
            </summary>
            <param name="request">request</param>
            <param name="expression">expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.FindDelegate(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,Grace.DependencyInjection.IInjectionContext,System.Boolean)">
            <summary>
            Find a delegate for a specific type
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <param name="consider"></param>
            <param name="key"></param>
            <param name="injectionContext"></param>
            <param name="checkMissing"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.CompileDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Compile a delegate
            </summary>
            <param name="scope"></param>
            <param name="expressionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.CreateInjectionDelegate(Grace.DependencyInjection.IInjectionScope,System.Type)">
            <summary>
            Create injection delegate 
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.ProcessExpressionResultForCompile(Grace.DependencyInjection.IActivationExpressionResult,System.Linq.Expressions.ParameterExpression[]@,System.Linq.Expressions.Expression[]@)">
            <summary>
            Process expression result for compiling
            </summary>
            <param name="expressionContext"></param>
            <param name="parameters"></param>
            <param name="extraExpressions"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.CompileExpressionResultToDelegate(Grace.DependencyInjection.IActivationExpressionResult,System.Linq.Expressions.ParameterExpression[],System.Linq.Expressions.Expression[],System.Linq.Expressions.Expression)">
            <summary>
            Compiles an expression result to a delegate
            </summary>
            <param name="expressionContext"></param>
            <param name="parameters"></param>
            <param name="extraExpressions"></param>
            <param name="finalExpression"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.ProcessMissingStrategyProviders(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Process missing strategy providers
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.LocateStrategyFromCollectionContainers(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locate a strategy from collection containers
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <param name="consider"></param>
            <param name="key"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyCompiler.FindKeyedDelegate(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object)">
            <summary>
            Find keyed delegate from strategies
            </summary>
            <param name="scope">scope</param>
            <param name="locateType">locate type</param>
            <param name="consider">filter for strategies</param>
            <param name="key">key to use during locate</param>
            <returns>delegate</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ActivationStrategyMetadata">
            <summary>
            Metadata for activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Type,System.Object}},Grace.Data.Immutable.ImmutableHashTree{System.Object,System.Object})">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="exportAs"></param>
            <param name="exportAsKeyed"></param>
            <param name="metadata"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.Count">
            <summary>Gets the number of elements in the collection.</summary>
            <returns>The number of elements in the collection. </returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.ContainsKey(System.Object)">
            <summary>Determines whether the read-only dictionary contains an element that has the specified key.</summary>
            <returns>true if the read-only dictionary contains an element that has the specified key; otherwise, false.</returns>
            <param name="key">The key to locate.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.TryGetValue(System.Object,System.Object@)">
            <summary>Gets the value that is associated with the specified key.</summary>
            <returns>true if the object that implements the <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" /> interface contains an element that has the specified key; otherwise, false.</returns>
            <param name="key">The key to locate.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value" /> parameter. This parameter is passed uninitialized.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.Item(System.Object)">
            <summary>Gets the element that has the specified key in the read-only dictionary.</summary>
            <returns>The element that has the specified key in the read-only dictionary.</returns>
            <param name="key">The key to locate.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key" /> is not found. </exception>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.Keys">
            <summary>Gets an enumerable collection that contains the keys in the read-only dictionary. </summary>
            <returns>An enumerable collection that contains the keys in the read-only dictionary.</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.Values">
            <summary>Gets an enumerable collection that contains the values in the read-only dictionary.</summary>
            <returns>An enumerable collection that contains the values in the read-only dictionary.</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.ExportAs">
            <summary>
            Exported as 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.ExportAsKeyed">
            <summary>
            Exported as keyed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyMetadata.MetadataMatches(System.Object,System.Object)">
            <summary>
            Check to see if specific metadata matches
            </summary>
            <param name="key">key to use</param>
            <param name="value">value to compare</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IActivationStrategyCreator">
            <summary>
            Interface to create different types of activation strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetCompiledDecoratorStrategy(System.Type)">
            <summary>
            Get new commpiled decorator
            </summary>
            <param name="activationType">type of decorator</param>
            <returns>new decorator</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetCompiledExportStrategy(System.Type)">
            <summary>
            Get new compiled export strategy
            </summary>
            <param name="exportType">type being exported</param>
            <returns>new compiled export strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetConstantStrategy``1(``0)">
            <summary>
            Get new constant export strategy
            </summary>
            <typeparam name="T">type of constant</typeparam>
            <param name="value">constant value</param>
            <returns>constant export strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFactoryStrategy``1(System.Func{``0})">
            <summary>
            Get new factory strategy no arg
            </summary>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>new factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFactoryStrategy``2(System.Func{``0,``1})">
            <summary>
            Get new factory strategy one arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFactoryStrategy``3(System.Func{``0,``1,``2})">
            <summary>
            Get new factory strategy two arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFactoryStrategy``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Get new factory strategy three arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="T3">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFactoryStrategy``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Get new factory strategy four arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="T3">dependeny</typeparam>
            <typeparam name="T4">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFactoryStrategy``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Get new factory strategy five arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="T3">dependeny</typeparam>
            <typeparam name="T4">dependeny</typeparam>
            <typeparam name="T5">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFuncDecoratorStrategy``1(System.Func{``0,``0})">
            <summary>
            Get new decorator strategy
            </summary>
            <typeparam name="T">type to decorate</typeparam>
            <param name="func">decorate func</param>
            <returns>new decorator strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFuncStrategy``1(System.Func{``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFuncWithScopeStrategy``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFuncWithStaticContextStrategy``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetFuncWithInjectionContextStrategy``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetExpressionExportStrategy``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Get expression export strategy
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetCompiledWrapperStrategy(System.Type)">
            <summary>
            Get new compiled wrapper strategy
            </summary>
            <param name="type">wrapper type</param>
            <returns>new wrapper strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyCreator.GetTypeSetConfiguration(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            New type set configuration
            </summary>
            <param name="types">types to export</param>
            <returns>type set configuration</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ActivationStrategyProvider">
            <summary>
            Provides activation strategies for configuration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
            <param name="exportExpressionBuilder"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetExpressionExportStrategy``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Get expression export strategy
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetCompiledWrapperStrategy(System.Type)">
            <summary>
            Get new compiled wrapper strategy
            </summary>
            <param name="type">wrapper type</param>
            <returns>new wrapper strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetTypeSetConfiguration(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            New type set configuration
            </summary>
            <param name="types">types to export</param>
            <returns>type set configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetCompiledExportStrategy(System.Type)">
            <summary>
            Get new compiled export strategy
            </summary>
            <param name="exportType">type being exported</param>
            <returns>new compiled export strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetCompiledDecoratorStrategy(System.Type)">
            <summary>
            Get new commpiled decorator
            </summary>
            <param name="activationType">type of decorator</param>
            <returns>new decorator</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetConstantStrategy``1(``0)">
            <summary>
            Get new constant export strategy
            </summary>
            <typeparam name="T">type of constant</typeparam>
            <param name="value">constant value</param>
            <returns>constant export strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFactoryStrategy``1(System.Func{``0})">
            <summary>
            Get new factory strategy no arg
            </summary>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>new factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFuncStrategy``1(System.Func{``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFuncWithScopeStrategy``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFuncWithStaticContextStrategy``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFuncWithInjectionContextStrategy``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Get new func strategy
            </summary>
            <typeparam name="T">type being created</typeparam>
            <param name="func">create func</param>
            <returns>new strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFactoryStrategy``2(System.Func{``0,``1})">
            <summary>
            Get new factory strategy one arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFactoryStrategy``3(System.Func{``0,``1,``2})">
            <summary>
            Get new factory strategy two arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFactoryStrategy``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Get new factory strategy three arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="T3">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFactoryStrategy``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Get new factory strategy four arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="T3">dependeny</typeparam>
            <typeparam name="T4">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFactoryStrategy``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Get new factory strategy five arg
            </summary>
            <typeparam name="T1">dependeny</typeparam>
            <typeparam name="T2">dependeny</typeparam>
            <typeparam name="T3">dependeny</typeparam>
            <typeparam name="T4">dependeny</typeparam>
            <typeparam name="T5">dependeny</typeparam>
            <typeparam name="TResult">type being created</typeparam>
            <param name="factory">factory method</param>
            <returns>factory strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ActivationStrategyProvider.GetFuncDecoratorStrategy``1(System.Func{``0,``0})">
            <summary>
            Get new decorator strategy
            </summary>
            <typeparam name="T">type to decorate</typeparam>
            <param name="func">decorate func</param>
            <returns>new decorator strategy</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IAttributeDiscoveryService">
            <summary>
            Service for discovering attributes and sharing them
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IAttributeDiscoveryService.GetAttributes(System.Object)">
            <summary>
            Get attributes from MethodInfo, PropertyInfo, ParameterInfo, and FieldInfo
            </summary>
            <param name="value">MethodInfo, PropertyInfo, ParameterInfo, and FieldInfo</param>
            <returns>attributes</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.AttributeDiscoveryService">
            <summary>
            attribute dicovery service
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributeDiscoveryService.GetAttributes(System.Object)">
            <summary>
            Get attributes from MethodInfo, PropertyInfo, ParameterInfo, and FieldInfo
            </summary>
            <param name="value">MethodInfo, PropertyInfo, ParameterInfo, and FieldInfo</param>
            <returns>attributes</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.BaseExportLocatorScope">
            <summary>
            base locator scope used by InjectionScope and LifetimeScope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.BaseExportLocatorScope.ArrayLengthMinusOne">
            <summary>
            length of the activation delegates array minus one
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.BaseExportLocatorScope.ActivationDelegates">
            <summary>
            array of activation delegates
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseExportLocatorScope.#ctor(Grace.DependencyInjection.IExportLocatorScope,System.String,Grace.Data.Immutable.ImmutableHashTree{System.Type,Grace.DependencyInjection.ActivationStrategyDelegate}[])">
            <summary>
            Default constructor
            </summary>
            <param name="parent">parent scope</param>
            <param name="name">name of scope</param>
            <param name="activationDelegates">activation delegates</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseExportLocatorScope.Parent">
            <summary>
            Parent for scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseExportLocatorScope.ScopeName">
            <summary>
            Name of scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseExportLocatorScope.ScopeId">
            <summary>
            Scope id
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseExportLocatorScope.Keys">
            <summary>
            Keys for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseExportLocatorScope.Values">
            <summary>
            Values for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseExportLocatorScope.KeyValuePairs">
            <summary>
            Enumeration of all the key value pairs
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseExportLocatorScope.GetExtraData(System.Object)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="key">key of the data object to get</param>
            <returns>data value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseExportLocatorScope.SetExtraData(System.Object,System.Object,System.Boolean)">
            <summary>
            Sets extra data on the locator scope
            </summary>
            <param name="key">object name</param>
            <param name="newValue">new object value</param>
            <param name="replaceIfExists"></param>
            <returns>the final value of key</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseExportLocatorScope.GetLockObject(System.String)">
            <summary>
            Gets a named object that can be used for locking
            </summary>
            <param name="lockName">lock name</param>
            <returns>lock</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ICanLocateTypeService">
            <summary>
            Interface for service that tests if a type can be resolved
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICanLocateTypeService.CanLocate(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Can the service be located
            </summary>
            <param name="injectionScope">injection scope</param>
            <param name="type">type to be located</param>
            <param name="filter">filter for locate</param>
            <param name="key">key to use for locate</param>
            <param name="includeProviders"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CanLocateTypeService">
            <summary>
            Class tests if a type can be located
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CanLocateTypeService.CanLocate(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Can the service be located
            </summary>
            <param name="injectionScope">injection scope</param>
            <param name="type">type to be located</param>
            <param name="filter">filter for locate</param>
            <param name="key">key to use for locate</param>
            <param name="includeProviders"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledDecoratorStrategy">
            <summary>
            Strategy for user registered decorators
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledDecoratorStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="builder"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledDecoratorStrategy.ApplyAfterLifestyle">
            <summary>
            Apply the decorator after a lifestyle has been used
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledDecoratorStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledDecoratorStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy">
            <summary>
            Standard export strategy for all non generic types registered with the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="builder"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.GetDependencies(Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Dependencies needed to activate strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledExportStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledInitializationDecoratorStrategy`1">
            <summary>
            Decorator strategy for Func
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledInitializationDecoratorStrategy`1.#ctor(System.Func{`0,`0},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledInitializationDecoratorStrategy`1.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledInitializationDecoratorStrategy`1.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledInitializationDecoratorStrategy`1.InternalGetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Internal method for creating acivation expression
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledInitializationDecoratorStrategy`1.ApplyAfterLifestyle">
            <summary>
            Apply the decorator after a lifestyle has been used
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy">
            <summary>
            Strategy for user registered wrapper classes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="builder"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Gets decorator for expression
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="type">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.SetWrappedType(System.Type)">
            <summary>
            Set the type that is being wrapped
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.CompiledWrapperStrategy.SetWrappedGenericArgPosition(System.Int32)">
            <summary>
            Set the position of the generic arg that is being wrapped
            </summary>
            <param name="argPosition"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy">
            <summary>
            Abstract class that most strategies are based off of
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ActivationConfiguration">
            <summary>
            Activation configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType">type to activate</param>
            <param name="injectionScope">owning injection scope</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.InjectionScope">
            <summary>
            Injection scope for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.Priority">
            <summary>
            Priority for the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ActivationType">
            <summary>
            Type being activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ExportAs">
            <summary>
            Export as a particular type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ExportAsKeyed">
            <summary>
            Export as a keyed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ExportAsName">
            <summary>
            Export as a name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.HasConditions">
            <summary>
            Does the activation strategy have conditions for it's use
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.Conditions">
            <summary>
            Conditions for this activation strategy to be used
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.Lifestyle">
            <summary>
            lifestyle associated with the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.DisposalDelegate">
            <summary>
            Disposal delegate for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ConstructorSelectionMethod">
            <summary>
            Constructor selection method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ExternallyOwned">
            <summary>
            IS strategy externally owned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.SetMetadata(System.Object,System.Object)">
            <summary>
            Add metadata to strategy
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ActivationMethod">
            <summary>
            Method that's called when the type is activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.CustomScopeName">
            <summary>
            If not null then instance will be created in new scope.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.GetActivationConfiguration(System.Type)">
            <summary>
            Get activation configuration for strategy
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.Metadata">
            <summary>
            Get the metadata for this activation strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.GetDependencies(Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Dependencies needed to activate strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.AddExportAs(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="exportType">type to export as</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.AddExportAsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed type
            </summary>
            <param name="exportType">type to export as</param>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.AddExportAsName(System.String)">
            <summary>
            Export as name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.AddCondition(Grace.DependencyInjection.Conditions.ICompiledCondition)">
            <summary>
            Add condition for strategy
            </summary>
            <param name="condition">condition</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.MemberInjectionSelector(Grace.DependencyInjection.Impl.IMemberInjectionSelector)">
            <summary>
            Add member injection selector
            </summary>
            <param name="selector">member selector</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.MethodInjectionInfo(Grace.DependencyInjection.Impl.MethodInjectionInfo)">
            <summary>
            Add method injection info
            </summary>
            <param name="methodInjectionInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.EnrichmentDelegate(System.Object)">
            <summary>
            Delegate to enrich strategy with
            </summary>
            <param name="enrichmentDelegate">enrichment delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.ConstructorParameter(Grace.DependencyInjection.Impl.ConstructorParameterInfo)">
            <summary>
            Constructor parameter
            </summary>
            <param name="info"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.SelectedConstructor">
            <summary>
            Constructor to use when creating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.Keys">
            <summary>
            Keys for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.Values">
            <summary>
            Values for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.KeyValuePairs">
            <summary>
            Enumeration of all the key value pairs
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.GetExtraData(System.Object)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="key">key of the data object to get</param>
            <returns>data value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ConfigurableActivationStrategy.SetExtraData(System.Object,System.Object,System.Boolean)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="key">object name</param>
            <param name="newValue">new object value</param>
            <param name="replaceIfExists">replace value if key exists</param>
            <returns>the final value of key</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy">
            <summary>
            Strategy to export a property of field from another strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ICompiledExportStrategy,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="dependentStrategy"></param>
            <param name="propertyOrFieldName"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportedPropertyOrFieldStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy">
            <summary>
            Export strategy for exporting a method off an existing type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ICompiledExportStrategy,System.Reflection.MethodInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="methodInfo"></param>
            <param name="dependentStrategy"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.ExportMethodStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledDecoratorStrategy">
            <summary>
            Represents a generic decorator class
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledDecoratorStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="builder"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledDecoratorStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledDecoratorStrategy.GetActivationConfiguration(System.Type)">
            <summary>
            Get activation configuration for strategy
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledDecoratorStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledDecoratorStrategy.ApplyAfterLifestyle">
            <summary>
            Apply the decorator after a lifestyle has been used
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy">
            <summary>
            Export strategy for open generic types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="builder"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.GetActivationConfiguration(System.Type)">
            <summary>
            Get activation configuration for strategy
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledExportStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy">
            <summary>
            Wrapper strategy for generic type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
            <param name="builder"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.GetActivationConfiguration(System.Type)">
            <summary>
            Get activation configuration for strategy
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="type">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.SetWrappedType(System.Type)">
            <summary>
            Set the type that is being wrapped
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.GenericCompiledWrapperStrategy.SetWrappedGenericArgPosition(System.Int32)">
            <summary>
            Set the position of the generic arg that is being wrapped
            </summary>
            <param name="argPosition"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1">
            <summary>
            This strategy doesn't honor lifestyle or decorators, it's intended to be very simple
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1.#ctor(System.Func{Grace.DependencyInjection.IExportLocatorScope,`0},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope">owning injection scope</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleFuncExportStrategy`1.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleGenericStrategy">
            <summary>
            Abstract class for basing simple generic strategies on
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleGenericStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleGenericStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleGenericStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleGenericStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleGenericStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledStrategies.SimpleGenericStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IConcreteExportStrategyProvider">
            <summary>
            Concrete Export strategy provider
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConcreteExportStrategyProvider.AddFilter(System.Func{System.Type,System.Boolean})">
            <summary>
            Add Filter type filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ConcreteExportStrategyProvider">
            <summary>
            Provides export strategies for concrete types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConcreteExportStrategyProvider.AddFilter(System.Func{System.Type,System.Boolean})">
            <summary>
            Add Filter type filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConcreteExportStrategyProvider.CanLocate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Can a given request be located using this provider
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConcreteExportStrategyProvider.ProvideExports(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Provide exports for a missing type
            </summary>
            <param name="scope">scope to provide value</param>
            <param name="request">request</param>
            <returns>set of activation strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConcreteExportStrategyProvider.ShouldCreateConcreteStrategy(System.Type)">
            <summary>
            Should a type be exported
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ConstructorParameterInfo">
            <summary>
            Information about a constructor arguement
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConstructorParameterInfo.#ctor(System.Object)">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.ExportFunc">
            <summary>
            Func&lt;IExportLocator,IExtraDataProvider,TParam&gt;
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.ParameterName">
            <summary>
            Name of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.ParameterType">
            <summary>
            Type of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.DefaultValue">
            <summary>
            Default value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.ExportStrategyFilter">
            <summary>
            Export filter associated with this import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.EnumerableComparer">
            <summary>
            Comparer to use on enumerable
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.LocateWithKey">
            <summary>
            Locate parameter with key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.IsDynamic">
            <summary>
            Is the parameter dynamic
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConstructorParameterInfo.UseType">
            <summary>
            Use specific type for parameter
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DefaultValueInformation">
            <summary>
            Default value information to be used for during import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DefaultValueInformation.DefaultValue">
            <summary>
            Default value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DisposalScope">
            <summary>
            class for tracking and disposing objects
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DisposalScope.DisposeEntry">
            <summary>
            For memory allocation and execution performance I've written a one off linked list to track items for disposal
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope.DisposeEntry.DisposeItem">
            <summary>
            Item to be disposed
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope.DisposeEntry.CleanupDelegate">
            <summary>
            Cleanup delegate that was passed in, this is a wrapper around the original delegate that was passed in
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope.DisposeEntry.Next">
            <summary>
            Next entry to dispose
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope.DisposeEntry.Empty">
            <summary>
            Empty entry
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope._entry">
            <summary>
            Internal list of disposal entries
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.Dispose">
            <summary>
            Dispose of scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.AddDisposable``1(``0)">
            <summary>
            Add an object for disposal tracking
            </summary>
            <param name="disposable">object to track for disposal</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.AddDisposable``1(``0,System.Action{``0})">
            <summary>
            Add an object for disposal tracking
            </summary>
            <param name="disposable">disposable object to track</param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IDynamicArrayLocator">
            <summary>
            Inteface for creating an array that is located dynamically
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IDynamicArrayLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locate dynamic array
            </summary>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="type"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DynamicArrayLocator">
            <summary>
            Creates an array of element type 
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DynamicArrayLocator.ArrayCreateDelegate">
            <summary>
            Delegate for creating dynamic array
            </summary>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DynamicArrayLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locate dynamic array
            </summary>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="type"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DynamicArrayLocator.ArrayCreateMethod``1(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.ActivationStrategyFilter,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Static method to create an a dynamic array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IDynamicIEnumerableLocator">
            <summary>
            interface for creating enumerable locator
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IDynamicIEnumerableLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locate dynamic enumerable
            </summary>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="type"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DynamicIEnumerableLocator">
            <summary>
            creates enumerable dynamically
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DynamicIEnumerableLocator.EnumerableCreateDelegate">
            <summary>
            Delegate to create enumerable
            </summary>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DynamicIEnumerableLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,Grace.DependencyInjection.ActivationStrategyFilter,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locate dynamic enumerable
            </summary>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="type"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DynamicIEnumerableLocator.EnumerableCreateMethod``1(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.ActivationStrategyFilter,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            static method to create enumerable dynamic
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionScope"></param>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="consider"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.EnumerableStrategies.BaseGenericEnumerableStrategy">
            <summary>
            Base class for all enumerable strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.BaseGenericEnumerableStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.EnumerableStrategies.BaseGenericEnumerableStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.BaseGenericEnumerableStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableArrayStrategy">
            <summary>
            Strategy for creating ImmutableArray
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableArrayStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableArrayStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableCollectionStrategy">
            <summary>
            Strategy for creating System.Collections.Immutable 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableCollectionStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableCollectionStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableLinkListStrategy">
            <summary>
            Strategy for creating ImmutableLinkedList
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableLinkListStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableLinkListStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ImmutableLinkListStrategy.CreateImmutableLinkedList``1(``0[])">
            <summary>
            Creates an immutable linked list from elements
            </summary>
            <typeparam name="T"></typeparam>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.EnumerableStrategies.ListEnumerableStrategy">
            <summary>
            Strategy for creating List(T)
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ListEnumerableStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default cosntructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ListEnumerableStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.EnumerableStrategies.ReadOnlyCollectionStrategy">
            <summary>
            Strategy for creating ReadOnly(T) 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ReadOnlyCollectionStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.EnumerableStrategies.ReadOnlyCollectionStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportInitializeInspector">
            <summary>
            Inspector that will apply an enrichment delegate to call strategies that are of a specific type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInitializeInspector.#ctor(System.Object,System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="initializeDelegate"></param>
            <param name="initializeType"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportRegistrationBlock">
            <summary>
            Represents a block of registration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.IActivationStrategyCreator)">
            <summary>
            Default constructor
            </summary>
            <param name="owningScope"></param>
            <param name="strategyCreator"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetExportStrategies">
            <summary>
            Export strategies from the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetDecoratorStrategies">
            <summary>
            Decorators from the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetWrapperStrategies">
            <summary>
            Wrappers from the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetInspectors">
            <summary>
            Get inspectors registered in block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetMissingExportStrategyProviders">
            <summary>
            Get list of missing export strategy providers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetValueProviders">
            <summary>
            Get list of value providers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetMemberInjectionSelectors">
            <summary>
            Get member injection selectors
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddMemberInjectionSelector(Grace.DependencyInjection.Impl.IMemberInjectionSelector)">
            <summary>
            Add IMemberInjectionSelctor that selects 
            </summary>
            <param name="selector"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddModule(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Add configuration module
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export``1">
            <summary>
            Export a specific type
            </summary>
            <typeparam name="T">type to export</typeparam>
            <returns>export configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Type)">
            <summary>
            Export a specific type (open generics allowed)
            </summary>
            <param name="type">type to export</param>
            <returns>export configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Export a set of types
            </summary>
            <param name="types">types to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export a specific value
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instance">instance to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(System.Func{``0})">
            <summary>
            Export a specific type using a function
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">function to create instance</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,``0})">
            <summary>
            Export a specific type using an IExportLocatorScope
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">instance func</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,``0})">
            <summary>
            Export a specific type using IExportLocatorScope and StaticInjectionContext
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">isntance func</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Export a specific type using IExportLocatorScope, StaticInjectionContext and IInjectionContext
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunc">isntance func</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportExpression``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Export an expression tree
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFactory``1(System.Func{``0})">
            <summary>
            Export a specific type
            </summary>
            <typeparam name="TResult">exported type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFactory``2(System.Func{``0,``1})">
            <summary>
            Export a specific type that requires some dependency
            </summary>
            <typeparam name="TIn">dependency type</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export function</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFactory``3(System.Func{``0,``1,``2})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFactory``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="T3">dependency three</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFactory``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="T3">dependency three</typeparam>
            <typeparam name="T4">dependency four</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFactory``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Export a specific type that requires some dependencies
            </summary>
            <typeparam name="T1">dependency one</typeparam>
            <typeparam name="T2">dependency two</typeparam>
            <typeparam name="T3">dependency three</typeparam>
            <typeparam name="T4">dependency four</typeparam>
            <typeparam name="T5">dependency five</typeparam>
            <typeparam name="TResult">export type</typeparam>
            <param name="factory">export factory</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportWrapper(System.Type)">
            <summary>
            Export a type to be used as a wrapper rather than export (types like Func(), Owned, Meta are wrapper types)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.IsExported(System.Type,System.Object,Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Test if a type is exported
            </summary>
            <param name="type"></param>
            <param name="key"></param>
            <param name="excludeStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ClearExports(System.Func{Grace.DependencyInjection.ICompiledExportStrategy,System.Boolean})">
            <summary>
            Clears exports from current registration block, this does not unregister exports for previous configuration calls
            </summary>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportDecorator(System.Type)">
            <summary>
            Export a type that will be used as a decorator for exports
            </summary>
            <param name="type">decorator type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportDecorator``1(System.Func{``0,``0},System.Boolean)">
            <summary>
            Export a piece of logic that will be used to decorate exports upon creation
            </summary>
            <typeparam name="T">type to decorate</typeparam>
            <param name="apply">decorator logic</param>
            <param name="applyAfterLifestyle"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddInspector(Grace.DependencyInjection.IActivationStrategyInspector)">
            <summary>
            Add injection inspector that will be called to inspect all exports, wrappers and decorators (apply cross cutting configuration with an inspector)
            </summary>
            <param name="inspector">inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddInjectionValueProvider(Grace.DependencyInjection.IInjectionValueProvider)">
            <summary>
            Add IInjectionValueProvider allowing the developer to override the normal behavior for creating an injection value
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddMissingExportStrategyProvider(Grace.DependencyInjection.IMissingExportStrategyProvider)">
            <summary>
            Add missing export strategy provider
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddActivationStrategy(Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Add your own custom activation strategy
            </summary>
            <param name="activationStrategy">activation strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddExportStrategyProvider(Grace.DependencyInjection.Impl.IExportStrategyProvider)">
            <summary>
            Add your own strategy provider, usually used by 3rd party libraries to provide their own custom export types
            </summary>
            <param name="strategyProvider">strategy provider</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration">
            <summary>
            Configure a set of types for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.#ctor(Grace.DependencyInjection.Impl.IActivationStrategyCreator,System.Collections.Generic.IEnumerable{System.Type},Grace.DependencyInjection.IInjectionScopeConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="strategyCreator"></param>
            <param name="typesToExport"></param>
            <param name="scopeConfiguration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndCondition(System.Func{System.Type,System.Collections.Generic.IEnumerable{Grace.DependencyInjection.Conditions.ICompiledCondition}})">
            <summary>
            Add conditions for export
            </summary>
            <param name="conditionFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.BasedOn(System.Type)">
            <summary>
            Export all types based on speficied type by Type
            </summary>
            <param name="baseType">base type to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.BasedOn``1">
            <summary>
            Export all types based on speficied type by Type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterface``1">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="whereClause">where clause to test if the interface should be used for exporting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByName(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            Export by name
            </summary>
            <param name="nameFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByType">
            <summary>
            Export the selected classes by type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Exports by a set of types
            </summary>
            <param name="typeDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByKeyedTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Tuple{System.Type,System.Object}}})">
            <summary>
            Export a type by a set of keyed types
            </summary>
            <param name="keyedDelegate">keyed types</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude">exclude delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export types using their attributes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ImportConstructorSelection(System.Func{System.Type,Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator})">
            <summary>
            Set constructor selection method for individual exports
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Lifestyle">
            <summary>
            Lifestyle for set
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Set a particular life style
            </summary>
            <param name="lifestyle">lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.UsingLifestyle(System.Func{System.Type,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle})">
            <summary>
            Set a particular life style using a func
            </summary>
            <param name="lifestyleFunc">pick a lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Where(System.Func{System.Type,System.Boolean})">
            <summary>
            Export only types that match the filter provided
            </summary>
            <param name="typeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithInspector(Grace.DependencyInjection.IActivationStrategyInspector)">
            <summary>
            Add inspector for type set
            </summary>
            <param name="inspector"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExternallyOwned">
            <summary>
            Mark all types as externally owned
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.When">
            <summary>
            Add condition to exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ProvideExportStrategies">
            <summary>
            Get export strategies
            </summary>
            <returns>list of exports</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IActivationExpressionBuilder">
            <summary>
            interface for building Linq Expression tree for strategy activation
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IActivationExpressionBuilder.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get a linq expression to satisfy the request
            </summary>
            <param name="scope">scope</param>
            <param name="request">request</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IActivationExpressionBuilder.DecorateExportStrategy(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Decorate an export strategy with decorators
            </summary>
            <param name="scope">scope</param>
            <param name="request">request</param>
            <param name="strategy">strategy being decorated</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder">
            <summary>
            builder creates linq expression to satify request
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.EnumerableExpressionCreator">
            <summary>
            Enumerable expression creator
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.ArrayExpressionCreator">
            <summary>
            Array expression creator
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.WrapperExpressionCreator">
            <summary>
            Wrapper expression creator
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.#ctor(Grace.DependencyInjection.Impl.Expressions.IArrayExpressionCreator,Grace.DependencyInjection.Impl.Expressions.IEnumerableExpressionCreator,Grace.DependencyInjection.Impl.Expressions.IWrapperExpressionCreator,Grace.DependencyInjection.Impl.IInjectionContextValueProvider)">
            <summary>
            Default constructor
            </summary>
            <param name="arrayExpressionCreator"></param>
            <param name="enumerableExpressionCreator"></param>
            <param name="wrapperExpressionCreator"></param>
            <param name="contextValueProvider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get a linq expression to satisfy the request
            </summary>
            <param name="scope">scope</param>
            <param name="request">request</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetDynamicValue``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,System.Object,System.Boolean,System.Boolean,System.Object)">
            <summary>
            Get a value dynamically
            </summary>
            <typeparam name="T">value to get</typeparam>
            <param name="scope">scope</param>
            <param name="disposalScope">disposal scope to use</param>
            <param name="staticInjectionContext">static injection context </param>
            <param name="context">context for call</param>
            <param name="key"></param>
            <param name="isRequired"></param>
            <param name="hasDefault"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetValueFromInjectionContext(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Creates expression for calling method GetValueFromInjectionContext
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.DecorateExportStrategy(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Decorate an export strategy with decorators
            </summary>
            <param name="scope">scope</param>
            <param name="request">request</param>
            <param name="strategy">strategy being decorated</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetValueFromInjectionValueProviders(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get IInjectionValueProviders for expression result for request
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetValueFromRequest(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Type,System.Object)">
            <summary>
            Get expression result from request
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.ProcessPathNode(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Type,Grace.DependencyInjection.IActivationPathNode)">
            <summary>
            Get expression from decorator
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationType"></param>
            <param name="decorator"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetActivationExpressionFromStrategies(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get expression for non generic strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetExpressionFromGenericStrategies(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get expression for generic strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.GetExpressionFromStrategyCollection(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get expression from strategy collections (export and wrapper)
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.SelectStrategyFromCollection(Grace.DependencyInjection.IActivationStrategyCollection{Grace.DependencyInjection.ICompiledExportStrategy},Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Select the best strategy from collection to satisfy request
            </summary>
            <param name="collection"></param>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.ActivationExpressionForStrategy(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Gets an activation expression for a given strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="strategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.FindDecoratorsForStrategy(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Finds decorators for a strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="strategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.FindDecoratorsForType(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Type,Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Find decorators for a given type
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="type"></param>
            <param name="strategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionBuilder.CreateDecoratedActivationStrategy(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.ICompiledExportStrategy,System.Collections.Generic.List{Grace.DependencyInjection.ICompiledDecoratorStrategy})">
            <summary>
            Creates decorated expression for activation strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="strategy"></param>
            <param name="decorators"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ActivationServices">
            <summary>
            Services for request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationServices.#ctor(Grace.DependencyInjection.IActivationStrategyCompiler,Grace.DependencyInjection.Impl.Expressions.IActivationExpressionBuilder,Grace.DependencyInjection.Impl.IAttributeDiscoveryService,Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder,Grace.DependencyInjection.Impl.IInjectionContextCreator)">
            <summary>
            Default constructor
            </summary>
            <param name="compiler"></param>
            <param name="expressionBuilder"></param>
            <param name="attributeDiscoveryService"></param>
            <param name="exportExpressionBuilder"></param>
            <param name="injectionContextCreator"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationServices.AttributeDiscoveryService">
            <summary>
            Service for locating attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationServices.Compiler">
            <summary>
            activation compiler for request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationServices.LifestyleExpressionBuilder">
            <summary>
            Expression builder that takes lifestyle into consideration
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationServices.InjectionContextCreator">
            <summary>
            Injection context creator
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationServices.ExpressionBuilder">
            <summary>
            Expression builder
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.DecoratorActivationPathNode">
            <summary>
            Node in decorator path
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DecoratorActivationPathNode.#ctor(Grace.DependencyInjection.IDecoratorOrExportActivationStrategy,System.Type,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
            <param name="activationType"></param>
            <param name="lifestyle"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DecoratorActivationPathNode.Strategy">
            <summary>
            Strategy to use when activating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DecoratorActivationPathNode.ActivationType">
            <summary>
            Type the strategy satisfies
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DecoratorActivationPathNode.Lifestyle">
            <summary>
            Lifestyle for activation node
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DecoratorActivationPathNode.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get activation expression
            </summary>
            <param name="scope">scope for node</param>
            <param name="request">request for activation</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.WrapperActivationPathNode">
            <summary>
            Node in wrapper path
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.WrapperActivationPathNode.#ctor(Grace.DependencyInjection.IWrapperOrExportActivationStrategy,System.Type,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
            <param name="activationType"></param>
            <param name="lifestyle"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.WrapperActivationPathNode.Strategy">
            <summary>
            Strategy to use when activating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.WrapperActivationPathNode.ActivationType">
            <summary>
            Type the strategy satisfies
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.WrapperActivationPathNode.Lifestyle">
            <summary>
            Lifestyle for activation node
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.WrapperActivationPathNode.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get activation expression
            </summary>
            <param name="scope">scope for node</param>
            <param name="request">request for activation</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.PerDelegateData">
            <summary>
            Data that is per delegate
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.PerDelegateData.Keys">
            <summary>
            Keys for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.PerDelegateData.Values">
            <summary>
            Values for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.PerDelegateData.KeyValuePairs">
            <summary>
            Enumeration of all the key value pairs
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.PerDelegateData.GetExtraData(System.Object)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="key">key of the data object to get</param>
            <returns>data value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.PerDelegateData.SetExtraData(System.Object,System.Object,System.Boolean)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="key">object name</param>
            <param name="newValue">new object value</param>
            <param name="replaceIfExists">replace value if key exists</param>
            <returns>the final value of key</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest">
            <summary>
            Expression request object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.#ctor(System.Type,Grace.DependencyInjection.RequestType,Grace.DependencyInjection.IActivationServices,Grace.DependencyInjection.IExpressionConstants,System.Int32,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IDataPerDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="requestedType"></param>
            <param name="services"></param>
            <param name="constants"></param>
            <param name="objectGraphDepth"></param>
            <param name="requestingScope"></param>
            <param name="delegateData"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.ActivationType">
            <summary>
            Type being requested
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.LocateKey">
            <summary>
            Key to use for locating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.InjectedType">
            <summary>
            Type being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.RequestingStrategy">
            <summary>
            Requesting strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.RequestType">
            <summary>
            Type of request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.Parent">
            <summary>
            Parent request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.Filter">
            <summary>
            Export strategy filter to use
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.EnumerableComparer">
            <summary>
            IComparer to be used when locating array or 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.Services">
            <summary>
            Services for request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.Constants">
            <summary>
            Constants for request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.IsRequired">
            <summary>
            Is request required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.DisposalScopeExpression">
            <summary>
            Disposal scope expression to use
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.ScopeParameter">
            <summary>
            export locator scope parameter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.InjectionContextParameter">
            <summary>
            Injection context parameter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.Info">
            <summary>
            Info object for request (MethodInfo, FieldInfo, ParameterInfo)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.ObjectGraphDepth">
            <summary>
            Current object graph depth
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.UniqueId">
            <summary>
            Unique Id for request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.DecoratorPathNode">
            <summary>
            Current decorator path if decorating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.WrapperPathNode">
            <summary>
            Wrapper path if in the middel of wrapping
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.DefaultValue">
            <summary>
            Default value for request if not found
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.PopWrapperPathNode">
            <summary>
            Pop wrapper node off path
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.PopDecoratorPathNode">
            <summary>
            Pop decorator node off path
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetFilter(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Set filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetEnumerableComparer(System.Object)">
            <summary>
            Set the comparer for this request
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetDecoratorPath(Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.IActivationPathNode})">
            <summary>
            Set the decorator path for request
            </summary>
            <param name="path">node path</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetWrapperPath(Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.IActivationPathNode})">
            <summary>
            Set wrapper path for request
            </summary>
            <param name="wrappers">node path</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.GetWrappedStrategy">
            <summary>
            Get the currently wrapped strategy if one exists
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetIsRequired(System.Boolean)">
            <summary>
            Set is required value for request
            </summary>
            <param name="isRequired">is value required</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetLocateKey(System.Object)">
            <summary>
            Set key for request
            </summary>
            <param name="key">key to use for request</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetDefaultValue(Grace.DependencyInjection.IDefaultValueInformation)">
            <summary>
            Set default value for request
            </summary>
            <param name="defaultValue">default value</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.GetWrappedExportStrategy">
            <summary>
            Get wrapped strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.NewRequest(System.Type,Grace.DependencyInjection.IActivationStrategy,System.Type,Grace.DependencyInjection.RequestType,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Create new request from this request
            </summary>
            <param name="activationType">request type</param>
            <param name="requestingStrategy">requesting strategy</param>
            <param name="injectedType">type being injected into</param>
            <param name="requestType">request type</param>
            <param name="info">info for request</param>
            <param name="maintainPaths">maintain wrapper and decorator path</param>
            <param name="carryData"></param>
            <returns>new request</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.NewRootedRequest(System.Type,Grace.DependencyInjection.IInjectionScope,System.Boolean)">
            <summary>
            Creates new rooted request (for lifestyles)
            </summary>
            <param name="activationType"></param>
            <param name="requestingScope"></param>
            <param name="maintainPaths"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.RequestingScope">
            <summary>
            Original requesting scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.PerDelegateData">
            <summary>
            Data that is per delegate and won't transfer to other delegates
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.GetStaticInjectionContext">
            <summary>
            Get static injection context for request
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.CreateTargetInfo(Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.InjectionTargetInfo})">
            <summary>
            Create target info for request
            </summary>
            <param name="targetInfos">child targets</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.KnownValueExpressions">
            <summary>
            Known values that can be used in request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.IsDynamic">
            <summary>
            Is the request dynamic
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.AddKnownValueExpression(Grace.DependencyInjection.IKnownValueExpression)">
            <summary>
            Add known value expression to request
            </summary>
            <param name="knownValueExpression">known value expression</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.RequireInjectionContext">
            <summary>
            Require injection context for request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.InjectionContextRequired">
            <summary>
            Is injection context required
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.Keys">
            <summary>
            Keys for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.Values">
            <summary>
            Values for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.KeyValuePairs">
            <summary>
            Enumeration of all the key value pairs
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.GetExtraData(System.Object)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="key">key of the data object to get</param>
            <returns>data value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionRequest.SetExtraData(System.Object,System.Object,System.Boolean)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="key">object name</param>
            <param name="newValue">new object value</param>
            <param name="replaceIfExists">replace value if key exists</param>
            <returns>the final value of key</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult">
            <summary>
            Expression result
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.#ctor(Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Default constructor
            </summary>
            <param name="request"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.Request">
            <summary>
            Request that generated result
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.Expression">
            <summary>
            Expression for result
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.UsingFallbackExpression">
            <summary>
            True if no type was found and the default fallback expression was used
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.AddExpressionResult(Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Add child expression result
            </summary>
            <param name="result">expression result</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.AddExtraParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Add extra parameter for expression 
            </summary>
            <param name="parameter">parameter to declare</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.ExtraParameters">
            <summary>
            Extra parameters for result
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.AddExtraExpression(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Add extra expression to result 
            </summary>
            <param name="expression">expression for delegate</param>
            <param name="insertBeginning"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ActivationExpressionResult.ExtraExpressions">
            <summary>
            Extra expressions for result
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IArrayExpressionCreator">
            <summary>
            Interface for creating array expressions for a given request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IArrayExpressionCreator.GetArrayExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get linq expression to create
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator">
            <summary>
            Creates linq expression for array initialization
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.#ctor(Grace.DependencyInjection.Impl.Expressions.IWrapperExpressionCreator)">
            <summary>
            Default constructor
            </summary>
            <param name="wrapperExpressionCreator"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.GetArrayExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get linq expression to create
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.CreateSortedArrayExpression(System.Linq.Expressions.Expression,System.Type,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Create an expression to sort the array
            </summary>
            <param name="arrayInit"></param>
            <param name="arrayElementType"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.GetArrayExpressionList(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Type)">
            <summary>
            Get list of expressions to populate array
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="arrayElementType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.GetActivationExpressionResultsFromStrategies(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Type)">
            <summary>
            Get activation expression for export strategies
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="arrayElementType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.ProcessWrappers(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.IActivationExpressionRequest,System.Collections.Generic.List{Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Process wrappers looking for matching type
            </summary>
            <param name="scope"></param>
            <param name="arrayElementType"></param>
            <param name="request"></param>
            <param name="expressions"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.SortArray``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sort an array using a IComparer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arrayOfT"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.GetExpressionsFromCollections(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.IActivationExpressionRequest,System.Collections.Generic.List{Grace.DependencyInjection.IActivationExpressionResult},System.Type,Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.IActivationPathNode})">
            <summary>
            Get expression from collections
            </summary>
            <param name="scope"></param>
            <param name="arrayElementType"></param>
            <param name="request"></param>
            <param name="expressions"></param>
            <param name="wrappedType"></param>
            <param name="wrappers"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ArrayExpressionCreator.GetExpressionFromCollection(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.IActivationExpressionRequest,System.Collections.Generic.List{Grace.DependencyInjection.IActivationExpressionResult},Grace.DependencyInjection.IActivationStrategyCollection{Grace.DependencyInjection.ICompiledExportStrategy},System.Type,Grace.Data.Immutable.ImmutableLinkedList{Grace.DependencyInjection.IActivationPathNode})">
            <summary>
            Get expression from an activation strategy collection
            </summary>
            <param name="scope"></param>
            <param name="arrayElementType"></param>
            <param name="request"></param>
            <param name="expressions"></param>
            <param name="collection"></param>
            <param name="wrappedType"></param>
            <param name="wrappers"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.BestMatchConstructorExpressionCreator">
            <summary>
            Constructor expression creator that picks it's constructor based on available exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.BestMatchConstructorExpressionCreator.PickConstructor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo[])">
            <summary>
            This method is called when there are multiple constructors
            </summary>
            <param name="injectionScope"></param>
            <param name="configuration"></param>
            <param name="request"></param>
            <param name="constructors"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.BestMatchConstructorExpressionCreator.MatchInfo">
            <summary>
            Class used for keeping track of information about a constructor
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Expressions.BestMatchConstructorExpressionCreator.MatchInfo.Matched">
            <summary>
            how many parameters dependencies were satisfied
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Expressions.BestMatchConstructorExpressionCreator.MatchInfo.Missing">
            <summary>
            how many parameters dependencies could not be found
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Expressions.BestMatchConstructorExpressionCreator.MatchInfo.ConstructorInfo">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Create instantiation expression
            </summary>
            <param name="scope">scope the configuration is associated with</param>
            <param name="request">expression request</param>
            <param name="activationConfiguration">configuration</param>
            <returns>expression result</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Create instantiation expression
            </summary>
            <param name="scope">scope the configuration is associated with</param>
            <param name="request">expression request</param>
            <param name="activationConfiguration">configuration</param>
            <returns>expression result</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.GetParameterExpressionsForConstructor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo)">
            <summary>
            Get a list of expressions for the parameters in a constructor
            </summary>
            <param name="injectionScope">injection scope</param>
            <param name="configuration">configuration for strategy</param>
            <param name="request">request</param>
            <param name="constructor">constructor</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.FindParameterInfoExpression(System.Reflection.ParameterInfo,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Find matching ConstructorParameterInfo if one exists
            </summary>
            <param name="parameter"></param>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.GetParameterExpression(System.Reflection.ParameterInfo,Grace.DependencyInjection.Impl.ConstructorParameterInfo,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get expression for parameter
            </summary>
            <param name="parameter"></param>
            <param name="parameterInfo"></param>
            <param name="injectionScope"></param>
            <param name="configuration"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.CallExportFunc(Grace.DependencyInjection.IActivationStrategy,System.Reflection.ParameterInfo,Grace.DependencyInjection.Impl.ConstructorParameterInfo,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Boolean)">
            <summary>
            Create expression to call func
            </summary>
            <param name="strategy"></param>
            <param name="parameter"></param>
            <param name="parameterInfo"></param>
            <param name="injectionScope"></param>
            <param name="request"></param>
            <param name="configurationExternallyOwned"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.ShouldTrackDisposable(System.Boolean,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Should the export be tracked for disposal
            </summary>
            <param name="configurationExternallyOwned"></param>
            <param name="scope"></param>
            <param name="strategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.PickConstructor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            This method is used to pick a constructor from a type
            </summary>
            <param name="requestingScope"></param>
            <param name="configuration"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.PickConstructor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo[])">
            <summary>
            This method is called when there are multiple constructors
            </summary>
            <param name="injectionScope"></param>
            <param name="configuration"></param>
            <param name="request"></param>
            <param name="constructors"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.CreateTraceMessageForConstructor(System.Reflection.ConstructorInfo,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Creates trace message for specific constructor
            </summary>
            <param name="constructor"></param>
            <param name="activationConfiguration"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.GetDependenciesForConstructor(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo)">
            <summary>
            Get a list of dependencies for a constructor
            </summary>
            <param name="configuration"></param>
            <param name="request"></param>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.CreateConstructorExpression(Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo,System.Collections.Generic.List{Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Creates an expression to call a constructor given a ConstructorInfo and a list of parameters
            </summary>
            <param name="request">request</param>
            <param name="constructor">constructor</param>
            <param name="expressions">parameters</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ConstructorExpressionCreator.CanGetValueFromInfo(Grace.DependencyInjection.Impl.TypeActivationConfiguration,System.Reflection.ParameterInfo)">
            <summary>
            Test if the parameter was specified 
            </summary>
            <param name="configuration"></param>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder">
            <summary>
            interface for building expressions for a activation type using lifestyles
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder.TypeExpressionBuilder">
            <summary>
            Type expression builder
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IDefaultStrategyExpressionBuilder.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get activation expression for type configuration
            </summary>
            <param name="scope">scope</param>
            <param name="request">request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="lifestyle">lifestyle</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.DefaultStrategyExpressionBuilder">
            <summary>
            class builds expressions for activation configurations using lifestyles
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DefaultStrategyExpressionBuilder.#ctor(Grace.DependencyInjection.Impl.Expressions.ITypeExpressionBuilder)">
            <summary>
            Default constructor
            </summary>
            <param name="typeExpressionBuilder"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DefaultStrategyExpressionBuilder.TypeExpressionBuilder">
            <summary>
            Type expression builder
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DefaultStrategyExpressionBuilder.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get activation expression for type configuration
            </summary>
            <param name="scope">scope</param>
            <param name="request">request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="lifestyle">lifestyle</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IDisposalScopeExpressionCreator">
            <summary>
            Interface for creating linq expression to add instance to disposal scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IDisposalScopeExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create expression to add instance to disposal scope
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="result">result for instantiation</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.DisposalScopeExpressionCreator">
            <summary>
            Creates linq expression that add instance to disposal scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DisposalScopeExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create expression to add instance to disposal scope
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="result">result for instantiation</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DisposalScopeExpressionCreator.AddMethod">
            <summary>
            Method info for add method on IDisposalScope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DisposalScopeExpressionCreator.AddMethodWithCleanup">
            <summary>
            Method info for add method on IDisposalScope with cleanup delegate
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator">
            <summary>
            Creates a dynamic constructor expression that calls the correct constructor based on what's available in extra data
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Create instantiation expression
            </summary>
            <param name="scope">scope the configuration is associated with</param>
            <param name="request">expression request</param>
            <param name="activationConfiguration">configuration</param>
            <returns>expression result</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.CreateCallExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.ActivationStrategyDelegate)">
            <summary>
            Create call expression for delegate
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationConfiguration"></param>
            <param name="activationDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.CreateActivationDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Given an expression create an activation delegate
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationConfiguration"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.PickConstructor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo[])">
            <summary>
            This method is called when there are multiple constructors
            </summary>
            <param name="injectionScope"></param>
            <param name="configuration"></param>
            <param name="request"></param>
            <param name="constructors"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.DynamicCanLocate``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IInjectionContext,System.String)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="context"></param>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.DynamicLocate``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Boolean,System.Boolean,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="parameterName"></param>
            <param name="isRequired"></param>
            <param name="useDefault"></param>
            <param name="defaultVlalue"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.DynamicCanLocateMethodInfo">
            <summary>
            Method to use for can locate
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.DynamicConstructorExpressionCreator.DynamicLocateMethodInfo">
            <summary>
            Method to use for locate
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IEnrichmentExpressionCreator">
            <summary>
            interface for creating enrichment expressions for activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IEnrichmentExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create enrichment expressions
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="result">expression result</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.EnrichmentExpressionCreator">
            <summary>
            class for creating enrichment expressions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.EnrichmentExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create enrichment expressions
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="result">expression result</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IEnumerableExpressionCreator">
            <summary>
            interface for creating enumerable expressions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IEnumerableExpressionCreator.GetEnumerableExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.Expressions.IArrayExpressionCreator)">
            <summary>
            Get expression for creating enumerable
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="arrayExpressionCreator">array expression creator</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.EnumerableExpressionCreator">
            <summary>
            class for creating enumerable expressions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.EnumerableExpressionCreator.GetEnumerableExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.Expressions.IArrayExpressionCreator)">
            <summary>
            Get expression for creating enumerable
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="arrayExpressionCreator">array expression creator</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.EnumerableExpressionCreator.CreateEnumerableExpressionUsingArrayExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.Expressions.IArrayExpressionCreator)">
            <summary>
            Create enumerable expression that is an array
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="arrayExpressionCreator"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.EnumerableExpressionCreator.CreateEnumerableExpressionUsingCustomCreator(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.Expressions.IArrayExpressionCreator,Grace.DependencyInjection.IEnumerableCreator)">
            <summary>
            Create enumerable expression using a custom creator
            </summary>
            <param name="scope">injection scope</param>
            <param name="request">expression request</param>
            <param name="arrayExpressionCreator">array creator</param>
            <param name="enumerableCreator">custom enumerable creator</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.EnumerableExpressionCreator.CreateEnumerableMethod">
            <summary>
            Create enumerable method
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ExpressionConstants">
            <summary>
            represents a set of constants that can be used while creating linq expression
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Expressions.ExpressionConstants.Default">
            <summary>
            Default expression constants
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ExpressionConstants.RootDisposalScope">
            <summary>
            Root disposal scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ExpressionConstants.ScopeParameter">
            <summary>
            Scope parameter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ExpressionConstants.InjectionContextParameter">
            <summary>
            IInjectionContext parameter
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities">
            <summary>
            Expression utilities
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.CreateExpressionsForTypes(Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Type,System.Type[])">
            <summary>
            Create an array of expressions based off an array of types
            </summary>
            <param name="strategy"></param>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="resultType"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.CreateExpressionForDelegate(System.Delegate,System.Boolean,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Create an expression to call delegate and apply null check and disposal logic
            </summary>
            <param name="delegateInstance"></param>
            <param name="allowDisposableTracking"></param>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.ApplyNullCheckAndAddDisposal(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Applies null check and disposal scope tracking logic to an expression
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="expression"></param>
            <param name="allowDisposableTracking"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.CheckForNull``1(Grace.DependencyInjection.StaticInjectionContext,``0)">
            <summary>
            Check value for null
            </summary>
            <typeparam name="T">type of value</typeparam>
            <param name="context">static context</param>
            <param name="value">value to check</param>
            <returns>non null value</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.CheckForNullMethodInfo">
            <summary>
            Method info for CheckForNull
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.AddToDisposalScope``1(Grace.DependencyInjection.IDisposalScope,``0)">
            <summary>
            Add instance to disposal scope and return it
            </summary>
            <typeparam name="T"></typeparam>
            <param name="disposalScope"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.AddToDisposalScopeMethodInfo">
            <summary>
            Method info for AddToDisposalScope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.CheckForNullAndAddToDisposalScope``1(Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.StaticInjectionContext,``0)">
            <summary>
            Check for null and then add to disposal scope
            </summary>
            <typeparam name="T"></typeparam>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.CheckForNullAndAddToDisposalScopeMethodInfo">
            <summary>
            Method info for CheckForNullAndAddToDisposalScope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.ValueOrDefault``1(``0,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ExpressionUtilities.AddToDisposableScopeOrDefault``1(Grace.DependencyInjection.IDisposalScope,``0,``0)">
            <summary>
            Add to disposal scope or use default
            </summary>
            <typeparam name="T"></typeparam>
            <param name="disposalScope"></param>
            <param name="tValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IInstantiationExpressionCreator">
            <summary>
            implementation for creating an instantiation expression for a type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IInstantiationExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IInstantiationExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Create instantiation expression
            </summary>
            <param name="scope">scope the configuration is associated with</param>
            <param name="request">expression request</param>
            <param name="activationConfiguration">configuration</param>
            <returns>expression result</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.InstantiationExpressionCreator">
            <summary>
            Creates instantiation expressions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.InstantiationExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.InstantiationExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Create instantiation expression
            </summary>
            <param name="scope">scope the configuration is associated with</param>
            <param name="request">expression request</param>
            <param name="configuration">configuration</param>
            <returns>expression result</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.LeastParametersConstructorExpressionCreator">
            <summary>
            Creates constructor expression for least parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.LeastParametersConstructorExpressionCreator.PickConstructor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo[])">
            <summary>
            This method is called when there are multiple constructors
            </summary>
            <param name="injectionScope"></param>
            <param name="configuration"></param>
            <param name="request"></param>
            <param name="constructors"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.LocateExpressionReplacer">
            <summary>
            Replaces Arg.Locate expressions with expressions.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.LocateExpressionReplacer.#ctor(Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="request"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.LocateExpressionReplacer.Replace(System.Linq.Expressions.Expression)">
            <summary>
            Replace values in expression
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.LocateExpressionReplacer.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
            <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
            <param name="node">The expression to visit.</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IMemberInjectionExpressionCreator">
            <summary>
            Creates injection statements for properties and fields
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IMemberInjectionExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IMemberInjectionExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create member initialization statement if needed
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">expression request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="result">initialization expression</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.MemberInjectionExpressionCreator">
            <summary>
            Creates injection statements for members
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MemberInjectionExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MemberInjectionExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create member initialization statement if needed
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">expression request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="result">initialization expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MemberInjectionExpressionCreator.CreateMemberInjectExpressions(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Creates member injection statements
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationConfiguration"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MemberInjectionExpressionCreator.CreateNewMemeberInitExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult,System.Linq.Expressions.NewExpression)">
            <summary>
            Create member init expression
            </summary>
            <param name="scope">scope for configuration</param>
            <param name="request">request</param>
            <param name="activationConfiguration">activation configuration</param>
            <param name="result">result from instantation</param>
            <param name="newExpression">instantiation expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MemberInjectionExpressionCreator.GetMemberInjectionInfoForConfiguration(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Get dictionary of members that need to be injected
            </summary>
            <param name="scope">scope</param>
            <param name="request">expression request</param>
            <param name="activationConfiguration">activation configuration</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IMethodInvokeExpressionCreator">
            <summary>
            Creates expression to call method on type being instantiated
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IMethodInvokeExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IMethodInvokeExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create expressions for calling methods
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="activationConfiguration">configuration information</param>
            <param name="activationExpressionResult">expression result</param>
            <returns>expression result</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.MethodInvokeExpressionCreator">
            <summary>
            Creates expression to call methods on type being instantiated
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MethodInvokeExpressionCreator.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MethodInvokeExpressionCreator.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionResult)">
            <summary>
            Create expressions for calling methods
            </summary>
            <param name="scope">scope for strategy</param>
            <param name="request">request</param>
            <param name="activationConfiguration">configuration information</param>
            <param name="activationExpressionResult">expression result</param>
            <returns>expression result</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.MostParametersConstructorExpressionCreator">
            <summary>
            Creates a constructor expression when using most parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.MostParametersConstructorExpressionCreator.PickConstructor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.ConstructorInfo[])">
            <summary>
            This method is called when there are multiple constructors
            </summary>
            <param name="injectionScope"></param>
            <param name="configuration"></param>
            <param name="request"></param>
            <param name="constructors"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.PublicMemeberInjectionSelector">
            <summary>
            Select public members that can be injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.PublicMemeberInjectionSelector.#ctor(System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="picker"></param>
            <param name="injectMethods"></param>
            <param name="processAttributes"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.PublicMemeberInjectionSelector.IsRequired">
            <summary>
            Is the member required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.PublicMemeberInjectionSelector.DefaultValue">
            <summary>
            Default value for member
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.PublicMemeberInjectionSelector.GetPropertiesAndFields(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get a list of member injection info for a specific type
            </summary>
            <param name="type">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="request">request</param>
            <returns>members being injected</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.PublicMemeberInjectionSelector.GetMethods(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get Methods to inject
            </summary>
            <param name="type">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="request">request</param>
            <returns>methods being injected</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.SimpleKnownValueExpression">
            <summary>
            Represents a known value as a linq expression
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.SimpleKnownValueExpression.#ctor(System.Type,System.Linq.Expressions.Expression,System.Object,System.Nullable{System.Int32})">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="expression"></param>
            <param name="key"></param>
            <param name="position"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.SimpleKnownValueExpression.ActivationType">
            <summary>
            Type for expression
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.SimpleKnownValueExpression.Key">
            <summary>
            Hint for locating when multiple
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Expressions.SimpleKnownValueExpression.Position">
            <summary>
            Hint for where the value should be positioned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.SimpleKnownValueExpression.ValueExpression(Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Expression that represents the known value
            </summary>
            <param name="request">request for expression</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.ITypeExpressionBuilder">
            <summary>
            Builds expression using type activation configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ITypeExpressionBuilder.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.ITypeExpressionBuilder.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Get activation expression
            </summary>
            <param name="scope">scope</param>
            <param name="request">request for expression</param>
            <param name="activationConfiguration">configuration</param>
            <returns>result</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.TypeExpressionBuilder">
            <summary>
            expression builder
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.TypeExpressionBuilder.#ctor(Grace.DependencyInjection.Impl.Expressions.IInstantiationExpressionCreator,Grace.DependencyInjection.Impl.Expressions.IDisposalScopeExpressionCreator,Grace.DependencyInjection.Impl.Expressions.IMemberInjectionExpressionCreator,Grace.DependencyInjection.Impl.Expressions.IMethodInvokeExpressionCreator,Grace.DependencyInjection.Impl.Expressions.IEnrichmentExpressionCreator)">
            <summary>
            Default constructor
            </summary>
            <param name="instantiationExpressionCreator"></param>
            <param name="disposalScopeExpressionCreator"></param>
            <param name="memberInjectionExpressionCreator"></param>
            <param name="enrichmentExpressionCreator"></param>
            <param name="methodInvokeExpressionCreator"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.TypeExpressionBuilder.GetDependencies(Grace.DependencyInjection.Impl.TypeActivationConfiguration,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an enumeration of dependencies
            </summary>
            <param name="configuration">configuration object</param>
            <param name="request"></param>
            <returns>dependencies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.TypeExpressionBuilder.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.TypeActivationConfiguration)">
            <summary>
            Get activation expression
            </summary>
            <param name="scope">scope</param>
            <param name="request">request for expression</param>
            <param name="activationConfiguration">configuration</param>
            <returns>result</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.IWrapperExpressionCreator">
            <summary>
            interface for creating wrappers around exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IWrapperExpressionCreator.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for a request
            </summary>
            <param name="scope">scope for request</param>
            <param name="request">request</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IWrapperExpressionCreator.GetWrappers(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.IActivationExpressionRequest,System.Type@)">
            <summary>
            Get wrappers for a request
            </summary>
            <param name="scope"></param>
            <param name="type"></param>
            <param name="request"></param>
            <param name="wrappedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.IWrapperExpressionCreator.SetupWrappersForRequest(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Sets up wrappers for request
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Expressions.WrapperExpressionCreator">
            <summary>
            Creates linq expressions for wrappers
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.WrapperExpressionCreator.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for a request
            </summary>
            <param name="scope">scope for request</param>
            <param name="request">request</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.WrapperExpressionCreator.GetWrappers(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.IActivationExpressionRequest,System.Type@)">
            <summary>
            Get wrappers for a request
            </summary>
            <param name="scope"></param>
            <param name="type"></param>
            <param name="request"></param>
            <param name="wrappedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Expressions.WrapperExpressionCreator.SetupWrappersForRequest(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Sets up wrappers for request
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryFiveArgStrategy`6">
            <summary>
            Strategy for Func that take 5 dependencies and returns TResult
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryFiveArgStrategy`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryFourArgStrategy`5">
            <summary>
            Strategy for Func that take 4 dependencies and returns TResult
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryFourArgStrategy`5.#ctor(System.Func{`0,`1,`2,`3,`4},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryNoArgStrategy`1">
            <summary>
            Strategy for Func that take no dependencies and returns TResult
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryNoArgStrategy`1.#ctor(System.Func{`0},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryOneArgStrategy`2">
            <summary>
            Strategy for Func that take 1 dependency and returns TResult
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryOneArgStrategy`2.#ctor(System.Func{`0,`1},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryThreeArgStrategy`4">
            <summary>
            Strategy for Func that take 3 dependencies and returns TResult
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryThreeArgStrategy`4.#ctor(System.Func{`0,`1,`2,`3},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func">delegate</param>
            <param name="injectionScope">injection scope</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryTwoArgStrategy`3">
            <summary>
            Strategy for Func that take 2 dependencies and returns TResult
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FactoryStrategies.FactoryTwoArgStrategy`3.#ctor(System.Func{`0,`1,`2},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default cosntructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration">
            <summary>
            configuration object for decorator
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.#ctor(Grace.DependencyInjection.ICompiledDecoratorStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.ApplyAfterLifestyle">
            <summary>
            Apply decorator after lifestyle, by default it's before
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.As(System.Type)">
            <summary>
            Export as particular types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.When">
            <summary>
            Condition for decorator strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.WithCtorParam``2(System.Func{``0,``1})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.WithCtorParam``3(System.Func{``0,``1,``2})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.WithCtorParam``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.WithCtorParam``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorStrategyConfiguration.WithCtorParam``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <typeparam name="TArg5"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1">
            <summary>
            Constructor parameter configuration
            </summary>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.#ctor(Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration,Grace.DependencyInjection.Impl.ConstructorParameterInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
            <param name="constructorParameterInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filter">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.DefaultValue(`0)">
            <summary>
            Assign a default value if no better option is found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.DefaultValue(System.Func{`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.DefaultValue(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.IsDynamic(System.Boolean)">
            <summary>
            Mark the parameter as dynamic
            </summary>
            <param name="isDynamic"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.Named(System.String)">
            <summary>
            Name of the parameter being configured
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentDecoratorWithCtorConfiguration`1.Use(System.Type)">
            <summary>
            Use a specific type for parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1">
            <summary>
            Configuration object for an export instance
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.#ctor(Grace.DependencyInjection.IConfigurableActivationStrategy,Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Default constructor
            </summary>
            <param name="exportConfiguration"></param>
            <param name="registrationBlock"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as specific type
            </summary>
            <param name="type">type to export as</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed interface
            </summary>
            <param name="type">export type</param>
            <param name="key">export key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type
            </summary>
            <typeparam name="TInterface">type to export as</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.AsKeyed``1(System.Object)">
            <summary>
            Export as a specific keyed type
            </summary>
            <typeparam name="TExportType">type to export as</typeparam>
            <param name="key">key to export as</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export as specific name
            </summary>
            <param name="name">export name</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.ExternallyOwned">
            <summary>
            Mark an export as externally owned means the container will not track and dispose the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Only export if delegate returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Export using a specific lifestyle
            </summary>
            <param name="lifestyle">lifestlye to use</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.When">
            <summary>
            Use export under specific conditions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Set priority for export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.Lifestyle">
            <summary>
            Assign a lifestyle to this export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportInstanceConfiguration`1.GetStrategy">
            <summary>
            Get stragey from configuration
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportMemberConfiguration`1">
            <summary>
            Configuration object for exporting a member
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportMemberConfiguration`1.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0},Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy">strategy to wrap</param>
            <param name="exportStrategy">export strategy for member</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportMemberConfiguration`1.WithType(System.Type)">
            <summary>
            Control what type the member is exported as
            </summary>
            <param name="exportType">export type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportMemberConfiguration`1.WithCondition(Grace.DependencyInjection.Conditions.ICompiledCondition)">
            <summary>
            Add a condition for property export
            </summary>
            <param name="condition">condition to add</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IActivationStrategyProvider">
            <summary>
            Provides activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IActivationStrategyProvider.GetStrategy">
            <summary>
            Get stragey from configuration
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration">
            <summary>
            Configuration object for export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.#ctor(Grace.DependencyInjection.IConfigurableActivationStrategy,Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Default constructor
            </summary>
            <param name="exportConfiguration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type">type to export as</param>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed interface
            </summary>
            <param name="type">type to export as</param>
            <param name="key">key to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export as Name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export by interfaces
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Use specific constructor for use
            </summary>
            <param name="constructorInfo">constructor to use</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportConstructorSelection(Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator)">
            <summary>
            Specify the constructor selection algorithm
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportMembers(System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Import a specific member
            </summary>
            <param name="selector">selector method, can be null</param>
            <param name="injectMethods"></param>
            <returns>configuraiton object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.Lifestyle">
            <summary>
            Apply a lifestlye to export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Export only if function returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Assign a custom lifestyle to an export
            </summary>
            <param name="lifestyle"></param>
            <returns>configuraiton object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.When">
            <summary>
            Apply a condition on when to use strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Configure constructor parameter
            </summary>
            <typeparam name="TParam"></typeparam>
            <param name="paramFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithMetadata(System.Object,System.Object)">
            <summary>
            Export with specific metadata
            </summary>
            <param name="key">metadata key</param>
            <param name="value">metadata value</param>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Set the priority for the export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.DefinesNamedScope(System.String)">
            <summary>
            Defines a custom scope when creating instance
            </summary>
            <param name="customscope"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned so the container does not track for disposal
            </summary>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.GetStrategy">
            <summary>
            Get stragey from configuration
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1">
            <summary>
            Configuration object for export stategy
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.#ctor(Grace.DependencyInjection.ICompiledExportStrategy,Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Default constructor
            </summary>
            <param name="exportConfiguration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.Apply(System.Action{`0})">
            <summary>
            Apply an action to the export just after construction
            </summary>
            <param name="applyAction">action to apply to export upon construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type">type to export as</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a particular type
            </summary>
            <typeparam name="TInterface">type to export as</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed type
            </summary>
            <param name="type">export type</param>
            <param name="key">key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AsKeyed``1(System.Object)">
            <summary>
            Export as a keyed type
            </summary>
            <typeparam name="TInterface">export type</typeparam>
            <param name="key">key to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export as specific name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.DefinesNamedScope(System.String)">
            <summary>
            Creates a new scope and then resolves decorators inside of it.
            </summary>
            <param name="namedScope"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.DisposalCleanupDelegate(System.Action{`0})">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate">action to call when disposing</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.EnrichWithDelegate(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,`0,`0})">
            <summary>
            Enrich with delegate
            </summary>
            <param name="enrichmentDelegate">enrichment delegate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ExportMember``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Export a public member of the type (property, field or method with return value)
            </summary>
            <typeparam name="TValue">type to export</typeparam>
            <param name="memberExpression">member expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ExternallyOwned">
            <summary>
            Mark an export as externally owned means the container will not track and dispose the instance
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Func{`0}})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Use specific constructor for use
            </summary>
            <param name="constructorInfo">constructor to use</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportConstructorSelection(Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator)">
            <summary>
            Use a specific constructor selection method
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportMembers(System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Mark specific members to be injected
            </summary>
            <param name="selector">select specific members, if null all public members will be injected</param>
            <param name="injectMethod"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Import a specific property
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property">property expression</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Import a specific method on the type
            </summary>
            <param name="method">method to import</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.Lifestyle">
            <summary>
            Assign a lifestyle to this export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Export only if function returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Export using a specific lifestyle
            </summary>
            <param name="lifestyle">lifestlye to use</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.When">
            <summary>
            Add a condition to when this export can be used
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorCollectionParam``2">
            <summary>
            Import a collection allowing you to specify a filter and a sort order
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``2(System.Func{``0,``1})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``3(System.Func{``0,``1,``2})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <typeparam name="TArg5"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithMetadata(System.Object,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="key">metadata key</param>
            <param name="value">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Set the priority for the export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.GetStrategy">
            <summary>
            Get stragey from configuration
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2">
            <summary>
            Configuration class for importing a property
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TProp"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0},Grace.DependencyInjection.Impl.MemberInjectionInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
            <param name="memberInjectionInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            use a filter delegate when importing property
            </summary>
            <param name="consider">filter delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.DefaultValue(`1)">
            <summary>
            Default value if one can not be found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the property required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2">
            <summary>
            Configuration object for enumerable properties
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0},Grace.DependencyInjection.Impl.ConstructorParameterInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
            <param name="parameterInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.Named(System.String)">
            <summary>
            Parameter name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.SortBy(System.Collections.Generic.IComparer{`1})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.SortByProperty(System.Func{`1,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1">
            <summary>
            Constructor parameter configuration
            </summary>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration,Grace.DependencyInjection.Impl.ConstructorParameterInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
            <param name="constructorParameterInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.Named(System.String)">
            <summary>
            Name of the parameter being configured
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.Use(System.Type)">
            <summary>
            Use a specific type for parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filter">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.DefaultValue(`0)">
            <summary>
            Assign a default value if no better option is found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.DefaultValue(System.Func{`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.DefaultValue(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`1.IsDynamic(System.Boolean)">
            <summary>
            Mark the parameter as dynamic
            </summary>
            <param name="isDynamic"></param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2">
            <summary>
            Configuration object for constructor parameter
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0},Grace.DependencyInjection.Impl.ConstructorParameterInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
            <param name="constructorParameterInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.Consider(Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filter">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.DefaultValue(`1)">
            <summary>
            Assign a default value if no better option is found
            </summary>
            <param name="defaultValue">default value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.DefaultValue(System.Func{`1})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.DefaultValue(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,`1})">
            <summary>
            Default value func
            </summary>
            <param name="defaultValueFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.IsDynamic(System.Boolean)">
            <summary>
            Mark the parameter as dynamic (will be located from child scopes)
            </summary>
            <param name="isDynamic"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.Named(System.String)">
            <summary>
            Name of the parameter being configured
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorConfiguration`2.Use(System.Type)">
            <summary>
            Use specific type to satisfy parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentWrapperStrategyConfiguration">
            <summary>
            Configuration object for wrapper strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWrapperStrategyConfiguration.#ctor(Grace.DependencyInjection.Impl.IConfigurableCompiledWrapperStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="compiledWrapperStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWrapperStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentWrapperStrategyConfiguration.When">
            <summary>
            Apply a condition on when to use strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWrapperStrategyConfiguration.WrappedType(System.Type)">
            <summary>
            Set the type that is being wrapped
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWrapperStrategyConfiguration.WrappedGenericArg(System.Int32)">
            <summary>
            set the position of the generic arg being wrapped
            </summary>
            <param name="genericArgPosition"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IConfigurableCompiledWrapperStrategy">
            <summary>
            Wrapper that can be configured
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableCompiledWrapperStrategy.SetWrappedType(System.Type)">
            <summary>
            Set the type that is being wrapped
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableCompiledWrapperStrategy.SetWrappedGenericArgPosition(System.Int32)">
            <summary>
            Set the position of the generic arg that is being wrapped
            </summary>
            <param name="argPosition"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IDecoratorStrategyProvider">
            <summary>
            Class that provides decorators
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IDecoratorStrategyProvider.ProvideStrategies">
            <summary>
            Provide a list of decorator strategies
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider">
            <summary>
            Registration block that returns exports, decorators, wrappers and inspectors
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider.GetExportStrategies">
            <summary>
            Export strategies from the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider.GetDecoratorStrategies">
            <summary>
            Decorators from the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider.GetWrapperStrategies">
            <summary>
            Wrappers from the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider.GetInspectors">
            <summary>
            Get inspectors registered in block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider.GetMissingExportStrategyProviders">
            <summary>
            Get list of missing export strategy providers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider.GetValueProviders">
            <summary>
            Get list of value providers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportRegistrationBlockValueProvider.GetMemberInjectionSelectors">
            <summary>
            Get member injection selectors
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IExportStrategyProvider">
            <summary>
            Represents a class that provides export stragies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportStrategyProvider.ProvideExportStrategies">
            <summary>
            Get export strategies
            </summary>
            <returns>list of exports</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IInjectionContextCreator">
            <summary>
            interface to create new injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IInjectionContextCreator.CreateContext(System.Object)">
            <summary>
            Create new injection context
            </summary>
            <param name="extraData">current extra data</param>
            <returns>new context</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.MemberInjectionInfo">
            <summary>
            Information about a member that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MemberInjectionInfo.MemberInfo">
            <summary>
            Member info object
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MemberInjectionInfo.CreateExpression">
            <summary>
            Expression that can be used to satify import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MemberInjectionInfo.IsRequired">
            <summary>
            Is it required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MemberInjectionInfo.DefaultValue">
            <summary>
            Default value for member
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MemberInjectionInfo.IsDynamic">
            <summary>
            Should the locate be dynamic
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MemberInjectionInfo.LocateKey">
            <summary>
            key to use for locate
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MemberInjectionInfo.Filter">
            <summary>
            Filter to use for locate
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IMemberInjectionSelector">
            <summary>
            interface for selecting members that should be injected on a type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IMemberInjectionSelector.GetPropertiesAndFields(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get a list of member injection info for a specific type
            </summary>
            <param name="type">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="request">request</param>
            <returns>members being injected</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IMemberInjectionSelector.GetMethods(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get Methods to inject
            </summary>
            <param name="type">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="request">request</param>
            <returns>methods being injected</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ImplementationFactory">
            <summary>
            This is the DI container for Grace implementation
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ImplementationFactory.InjectionScope">
            <summary>
            Injection scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ImplementationFactory.ExportInstance``1(System.Func{Grace.DependencyInjection.Impl.ImplementationFactory,``0})">
            <summary>
            Export an instance of a type
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <param name="exportFunc">export func</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ImplementationFactory.ExportSingleton``1(System.Func{Grace.DependencyInjection.Impl.ImplementationFactory,``0})">
            <summary>
            Export a singleton
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <param name="exportFunc">export func</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ImplementationFactory.Locate``1">
            <summary>
            Locate instances
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ImplementationFactory.Clone">
            <summary>
            Clone implementation factory
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionContext">
            <summary>
            Injection context that can be created on the fly
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContext.#ctor">
            <summary>
            private constructor for cloning
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContext.#ctor(System.Object)">
            <summary>
            Default constructor
            </summary>
            <param name="extraData">extra data</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContext.Keys">
            <summary>
            Keys for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContext.Values">
            <summary>
            Values for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContext.KeyValuePairs">
            <summary>
            Enumeration of all the key value pairs
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContext.GetExtraData(System.Object)">
            <summary>
            Get data from context, returns null if not found
            </summary>
            <param name="key">key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContext.SetExtraData(System.Object,System.Object,System.Boolean)">
            <summary>
            Set data into context
            </summary>
            <param name="key"></param>
            <param name="newValue"></param>
            <param name="replaceIfExists"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContext.ExtraData">
            <summary>
            Original object that was passed in as extra data when locate was called
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContext.SharedData">
            <summary>
            Data container that is shared between all context for an object graph
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContext.GetValueByType(System.Type)">
            <summary>
            Get a value by type from the extra data
            </summary>
            <param name="type">type to locate</param>
            <returns>instance or null if one can't be found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContext.Clone">
            <summary>
            Clone the extra data provider
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionContextCreator">
            <summary>
            Creates new injection contexts
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContextCreator.CreateContext(System.Object)">
            <summary>
            Create new injection context
            </summary>
            <param name="extraData">current extra data</param>
            <returns>new context</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionContextSharedData">
            <summary>
            Data context that is shared between context in the same graph
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContextSharedData.Keys">
            <summary>
            Keys for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContextSharedData.Values">
            <summary>
            Values for data
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionContextSharedData.KeyValuePairs">
            <summary>
            Enumeration of all the key value pairs
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContextSharedData.GetExtraData(System.Object)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="key">key of the data object to get</param>
            <returns>data value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContextSharedData.SetExtraData(System.Object,System.Object,System.Boolean)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="key">object name</param>
            <param name="newValue">new object value</param>
            <param name="replaceIfExists"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContextSharedData.GetLockObject(System.String)">
            <summary>
            Get a lock object by a specific name
            </summary>
            <param name="lockName"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IInjectionContextValueProvider">
            <summary>
            Interface for getting data from extra data 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IInjectionContextValueProvider.GetValueFromInjectionContext``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,System.Object,Grace.DependencyInjection.IInjectionContext,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Get data from injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="locator"></param>
            <param name="staticContext"></param>
            <param name="key"></param>
            <param name="dataProvider"></param>
            <param name="defaultValue"></param>
            <param name="useDefault"></param>
            <param name="isRequired"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionContextValueProvider">
            <summary>
            Implementation for fetching data from context value
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContextValueProvider.GetValueFromInjectionContext``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,System.Object,Grace.DependencyInjection.IInjectionContext,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Get data from injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="locator"></param>
            <param name="staticContext"></param>
            <param name="key"></param>
            <param name="dataProvider"></param>
            <param name="defaultValue"></param>
            <param name="useDefault"></param>
            <param name="isRequired"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionContextValueProvider.GetValueFromExtraDataProvider``1(System.Object,Grace.Data.IExtraDataContainer,System.Object@)">
            <summary>
            Get value from extra data provider
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="dataProvider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionScope">
            <summary>
            Root injection scope that is inherited by the Dependency injection container
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorage">
            <summary>
            Internal field storage
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.DisposalScopeProvider">
            <summary>
            Disposal scope providers, this or DisposalScope must be set
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.DisposalScope">
            <summary>
            Default disposal scope, this or DisposalScopeProdiver must be set
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.ActivationStrategyAddLockName">
            <summary>
            string constant that is used to locate a lock for adding strategies to the container
            Note: Do not use this unless you are working on container internals
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.#ctor(System.Action{Grace.DependencyInjection.InjectionScopeConfiguration})">
            <summary>
            Constructor that takes configuration action
            </summary>
            <param name="configuration">configuration action</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.#ctor(Grace.DependencyInjection.IInjectionScopeConfiguration)">
            <summary>
            Constructor takes a configuration object
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.#ctor(Grace.DependencyInjection.IInjectionScopeConfiguration,Grace.DependencyInjection.IInjectionScope,System.String)">
            <summary>
            Configuration object constructor
            </summary>
            <param name="configuration"></param>
            <param name="parent"></param>
            <param name="name"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.ScopeConfiguration">
            <summary>
            Scope configuration
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.Grace#DependencyInjection#IInjectionScope#StrategyCompiler">
            <summary>
            Compiler that produces Activation Strategy Delegates
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.CanLocate(System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object)">
            <summary>
            Can Locator type
            </summary>
            <param name="type">type to locate</param>
            <param name="consider"></param>
            <param name="key">key to use while locating</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Locate(System.Type)">
            <summary>
            Locate a specific type
            </summary>
            <param name="type">type to locate</param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.LocateOrDefault(System.Type,System.Object)">
            <summary>
            Locate type or return default value
            </summary>
            <param name="type"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Locate``1">
            <summary>
            Locate type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.LocateOrDefault``1(``0)">
            <summary>
            Locate or return default
            </summary>
            <typeparam name="T"></typeparam>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Locate(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Locate specific type using extra data or key
            </summary>
            <param name="type">type to locate</param>
            <param name="extraData">extra data to be used during construction</param>
            <param name="consider">filter out exports you don't want to consider</param>
            <param name="withKey">key to use for locating type</param>
            <param name="isDynamic">skip cache and look through exports</param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Locate``1(System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Locate specific type using extra data or key
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="extraData">extra data</param>
            <param name="consider">filter out exports you don't want to consider</param>
            <param name="withKey">key to use during construction</param>
            <param name="isDynamic">skip cache and look at all strategies</param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.LocateAll(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate all instances of a type
            </summary>
            <param name="type">type to locate</param>
            <param name="extraData">extra data </param>
            <param name="consider">provide method to filter out exports</param>
            <param name="comparer">comparer to use for sorting</param>
            <returns>list of all type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.LocateAll``1(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all of a specific type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="type">type to locate</param>
            <param name="extraData">extra data to use during construction</param>
            <param name="consider">provide method to filter out exports</param>
            <param name="comparer">comparer to use for sorting</param>
            <returns>list of all located</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.TryLocate``1(``0@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Try to locate a specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value">located value</param>
            <param name="extraData">extra data to be used during construction</param>
            <param name="consider">filter out exports you don't want</param>
            <param name="withKey">key to use while locating</param>
            <param name="isDynamic">skip cache and look at all exports</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.TryLocate(System.Type,System.Object@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Try to locate an export by type
            </summary>
            <param name="type">locate type</param>
            <param name="value">out value</param>
            <param name="extraData">extra data to use during locate</param>
            <param name="consider">filter out exports you don't want</param>
            <param name="withKey">key to use during locate</param>
            <param name="isDynamic">skip cache and look at all exports</param>
            <returns>returns tue if export found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.LocateByName(System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Locate by name
            </summary>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.LocateAllByName(System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Locate all by specific name
            </summary>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.TryLocateByName(System.String,System.Object@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Try to locate by name
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.BeginLifetimeScope(System.String)">
            <summary>
            Create as a new IExportLocate scope
            </summary>
            <param name="scopeName">scope name</param>
            <returns>new scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.CreateContext(System.Object)">
            <summary>
            Create injection context
            </summary>
            <param name="extraData">extra data</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Configure(System.Action{Grace.DependencyInjection.IExportRegistrationBlock})">
            <summary>
            Configure the injection scope
            </summary>
            <param name="registrationBlock"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Configure with module
            </summary>
            <param name="module">configuration module</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.StrategyCollectionContainer">
            <summary>
            Strategies associated with this scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.WrapperCollectionContainer">
            <summary>
            Wrappers associated with this scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.DecoratorCollectionContainer">
            <summary>
            Decorators associated with this scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.MemberInjectionSelectors">
            <summary>
            Member
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.MissingExportStrategyProviders">
            <summary>
            List of missing export strategy providers
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionScope.InjectionValueProviders">
            <summary>
            List of value providers that can be used during construction of linq expression
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Grace#DependencyInjection#IInjectionScope#LocateFromChildScope(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Locate an export from a child scope
            </summary>
            <param name="childScope">scope where the locate originated</param>
            <param name="disposalScope"></param>
            <param name="type">type to locate</param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="key"></param>
            <param name="allowNull"></param>
            <param name="isDynamic"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Grace#DependencyInjection#IInjectionScope#LocateByNameFromChildScope(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Boolean)">
            <summary>
            
            </summary>
            <param name="childScope"></param>
            <param name="disposalScope"></param>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="allowNull"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Grace#DependencyInjection#IInjectionScope#InternalLocateAll``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Internal locate all method
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="type"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.Grace#DependencyInjection#IInjectionScope#InternalLocateAllByName(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="exportName"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.CreateChildScope(System.Action{Grace.DependencyInjection.IExportRegistrationBlock},System.String)">
            <summary>
            Creates a new child scope
            This is best used for long term usage, not per request scenario
            </summary>
            <param name="configure">configure scope</param>
            <param name="scopeName">scope name </param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.CreateConfiguration(System.Action{Grace.DependencyInjection.InjectionScopeConfiguration})">
            <summary>
            Creates a new configuration object
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionScope.CreateInjectionContextFromExtraData(System.Type,System.Object)">
            <summary>
            Create an injection context from extra data
            </summary>
            <param name="type"></param>
            <param name="extraData"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass">
            <summary>
            Class for storing fields for injection scope,
            Fields that are not on the fast path are put in this class to keep the injection scope as light as possible
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.MemberInjectionSelectors">
            <summary>
            List of member injection selectors
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.DynamicArrayLocator">
            <summary>
            Dynamic array locator
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.DynamicIEnumerableLocator">
            <summary>
            dynamic ienumerable locator
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.Wrappers">
            <summary>
            Wrappers for scope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.ValueProviders">
            <summary>
            Value providers
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.MissingExportStrategyProviders">
            <summary>
            Missing export strategy providers
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.ActivationStrategyCompiler">
            <summary>
            activation strategy compiler
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.StrategyCollectionContainer">
            <summary>
            Strategy collection
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.DecoratorCollectionContainer">
            <summary>
            Decorators
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.ScopeConfiguration">
            <summary>
            Scope configuration
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.LifetimeScopeProvider">
            <summary>
            Provides IExportLocatorScope when requested
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.InjectionContextCreator">
            <summary>
            Creates injection context when needed
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InjectionScope.InternalFieldStorageClass.CanLocateTypeService">
            <summary>
            Implementation to tell if a type can be located
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IInjectionStrategyDelegateCreator">
            <summary>
            provides the logic to create InjectionStrategyDelegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IInjectionStrategyDelegateCreator.CreateInjectionDelegate(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.IActivationExpressionRequest,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Create a new delegate for a given type
            </summary>
            <param name="scope">scope to use for creating</param>
            <param name="locateType">type to inject</param>
            <param name="request"></param>
            <param name="objectParameter"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator">
            <summary>
            Implementation for creating injection delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.CreateInjectionDelegate(Grace.DependencyInjection.IInjectionScope,System.Type,Grace.DependencyInjection.IActivationExpressionRequest,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Create a new delegate for a given type
            </summary>
            <param name="scope">scope to use for creating</param>
            <param name="locateType">type to inject</param>
            <param name="request"></param>
            <param name="objectParameter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.CreatePropertyInjectionExpressions(Grace.DependencyInjection.IInjectionScope,System.Type,System.Linq.Expressions.ParameterExpression,Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.InjectionStrategy,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <param name="instanceValue"></param>
            <param name="strategy"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.CreateMethodInjectionExpressions(Grace.DependencyInjection.IInjectionScope,System.Type,System.Linq.Expressions.ParameterExpression,Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.InjectionStrategy,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <param name="instanceValue"></param>
            <param name="strategy"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.CreateMethodInjectionExpression(Grace.DependencyInjection.IInjectionScope,System.Type,System.Linq.Expressions.ParameterExpression,Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.InjectionStrategy,Grace.DependencyInjection.IActivationExpressionRequest,System.Reflection.MethodInfo,Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo)">
            <summary>
            
            </summary>
            <param name="scope"></param>
            <param name="locateType"></param>
            <param name="instanceValue"></param>
            <param name="strategy"></param>
            <param name="request"></param>
            <param name="method"></param>
            <param name="importInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.InjectionStrategy">
            <summary>
            strategy used for requests
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.InjectionStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType">type to activate</param>
            <param name="injectionScope">owning injection scope</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionStrategyDelegateCreator.InjectionStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy">
            <summary>
            Base export strategy for all instance and factory exports
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.StrategyDelegate">
            <summary>
            delegate for the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.BaseInstanceExportStrategy.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Create expression that is implemented in child class
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.ConstantInstanceExportStrategy`1">
            <summary>
            Strategy that represents a constant value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.ConstantInstanceExportStrategy`1.#ctor(`0,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="constant"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.ConstantInstanceExportStrategy`1.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Create expression that is implemented in child class
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.ConstantInstanceExportStrategy`1.CreateExpression(Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.DelegateBaseExportStrategy`1">
            <summary>
            Base class for all delegate based strategies (i.e. FactoryOneArgStrategy etc)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.DelegateBaseExportStrategy`1.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope,System.Object)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="delegate">delegate instance</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.DelegateBaseExportStrategy`1.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Create expression that is implemented in child class
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.DelegateBaseExportStrategy`1.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Create expression that calls a delegate
            </summary>
            <param name="scope">scope for the request</param>
            <param name="request">activation request</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InstanceStrategies.DelegateBaseExportStrategy`1.DelegateInstance">
            <summary>
            Delegate to call
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.ExpressionExportStrategy`1">
            <summary>
            Strategy for export Expression Tree
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.ExpressionExportStrategy`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0}},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="expression"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.ExpressionExportStrategy`1.CreateExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Create expression that is implemented in child class
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.FuncInstanceExportStrategy`1">
            <summary>
            Strategy that represents Func with no arguemnts
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.FuncInstanceExportStrategy`1.#ctor(System.Func{`0},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.FuncWithInjectionContextInstanceExportStrategy`1">
            <summary>
            Strategy for a Func that takes locator scope, static injection context, and IInjectionContext
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.FuncWithInjectionContextInstanceExportStrategy`1.#ctor(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,Grace.DependencyInjection.IInjectionContext,`0},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.FuncWithScopeInstanceExportStrategy`1">
            <summary>
            Strategy for Func that takes IExportLocatorScope
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.FuncWithScopeInstanceExportStrategy`1.#ctor(System.Func{Grace.DependencyInjection.IExportLocatorScope,`0},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategies.FuncWithStaticContextInstanceExportStrategy`1">
            <summary>
            Strategy for Func that takes IExportLocatorScope and StaticInjectionContext
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategies.FuncWithStaticContextInstanceExportStrategy`1.#ctor(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,`0},Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="func"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IWrapperStrategyProvider">
            <summary>
            Provide a list of export wrappers
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IWrapperStrategyProvider.ProvideWrappers">
            <summary>
            Provide list of wrappers
            </summary>
            <returns>list of wrappers</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.KnownMemberInjectionSelector">
            <summary>
            Selects properties that should be injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownMemberInjectionSelector.#ctor(Grace.DependencyInjection.Impl.MemberInjectionInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="memberInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownMemberInjectionSelector.GetPropertiesAndFields(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get members to inject
            </summary>
            <param name="type"></param>
            <param name="injectionScope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownMemberInjectionSelector.GetMethods(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get Methods to inject
            </summary>
            <param name="type">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="request">request</param>
            <returns>methods being injected</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.KnownTypeStrategies.FuncTypeStrategy">
            <summary>
            Strategy for creating Func&lt;Type,object&gt;
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.FuncTypeStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default cosntructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy">
            <summary>
            Strategy for creating a KeyedLocateDelegate delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.GetDecoratorActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.AddSecondaryStrategy(Grace.DependencyInjection.ICompiledExportStrategy)">
            <summary>
            Add a secondary strategy for this export strategy
            </summary>
            <param name="secondaryStrategy">new secondary strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.SecondaryStrategies">
            <summary>
            Provide secondary strategies such as exporting property or method
            </summary>
            <returns>export strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.KnownTypeStrategies.KeyedLocateDelegateStrategy.CreateKeyedDelegate``2(Grace.DependencyInjection.IExportLocatorScope)">
            <summary>
            Creates a new keyed delegate
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="locatorScope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.LifetimeScope">
            <summary>
            Represents a scope that can be resolved from but doesn't allow exports to be registered in
            Note: This is the recommend scope for "per request" scenarios
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.#ctor(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IInjectionScope,System.String,Grace.Data.Immutable.ImmutableHashTree{System.Type,Grace.DependencyInjection.ActivationStrategyDelegate}[])">
            <summary>
            Default Constructor
            </summary>
            <param name="parent">parent for scope</param>
            <param name="injectionScope"></param>
            <param name="name">name of scope</param>
            <param name="activationDelegates">activation delegate cache</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.BeginLifetimeScope(System.String)">
            <summary>
            Create as a new IExportLocate scope
            </summary>
            <param name="scopeName">scope name</param>
            <returns>new scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.CanLocate(System.Type,Grace.DependencyInjection.ActivationStrategyFilter,System.Object)">
            <summary>
            Can Locator type
            </summary>
            <param name="type">type to locate</param>
            <param name="consider"></param>
            <param name="key">key to use while locating</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.CreateContext(System.Object)">
            <summary>
            Create injection context
            </summary>
            <param name="extraData">extra data</param>
            <returns>injection context</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.Locate(System.Type)">
            <summary>
            Locate a specific type
            </summary>
            <param name="type">type to locate</param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.LocateOrDefault(System.Type,System.Object)">
            <summary>
            Locate type or return default value
            </summary>
            <param name="type"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.Locate``1">
            <summary>
            Locate type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.LocateOrDefault``1(``0)">
            <summary>
            Locate or return default
            </summary>
            <typeparam name="T"></typeparam>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.Locate(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Locate specific type using extra data or key
            </summary>
            <param name="type">type to locate</param>
            <param name="extraData">extra data to be used during construction</param>
            <param name="consider"></param>
            <param name="withKey">key to use for locating type</param>
            <param name="isDynamic"></param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.Locate``1(System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Locate specific type using extra data or key
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="extraData">extra data</param>
            <param name="consider">filter out different strategies</param>
            <param name="withKey">key to use during construction</param>
            <param name="isDynamic">bypass the cache and look at all possible</param>
            <returns>located instance</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.LocateAll(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate all instances of a specific type
            </summary>
            <param name="type">type ot locate</param>
            <param name="extraData">extra data to be used while locating</param>
            <param name="consider">strategy filter</param>
            <param name="comparer">comparer to use to sort collection</param>
            <returns>list of objects</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.LocateAll``1(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all of a specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type">type to locate, can be null</param>
            <param name="extraData">extra data to use during locate</param>
            <param name="consider">filter for strategies</param>
            <param name="comparer">comparer</param>
            <returns>list of all T</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.TryLocate``1(``0@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            Try to locate an export by type
            </summary>
            <typeparam name="T">locate type</typeparam>
            <param name="value">out value</param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <param name="withKey"></param>
            <param name="isDynamic"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.TryLocate(System.Type,System.Object@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean)">
            <summary>
            try to locate a specific type
            </summary>
            <param name="type">type to locate</param>
            <param name="value">located value</param>
            <param name="extraData">extra data to be used during locate</param>
            <param name="consider">filter to use during location</param>
            <param name="withKey">key to use during locate</param>
            <param name="isDynamic">is the request dynamic</param>
            <returns>true if export could be located</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.LocateByName(System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Locate by name
            </summary>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.LocateAllByName(System.String,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Locate all by specific name
            </summary>
            <param name="name"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.TryLocateByName(System.String,System.Object@,System.Object,Grace.DependencyInjection.ActivationStrategyFilter)">
            <summary>
            Try to locate by name
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <param name="extraData"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifetimeScope.LocateFromParent(System.Type,System.Object,Grace.DependencyInjection.ActivationStrategyFilter,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Locate from a parent scope if it's not in the cache
            </summary>
            <param name="type">type to locate</param>
            <param name="extraData">extra data</param>
            <param name="consider">filter for strategies</param>
            <param name="key">key to use for locate</param>
            <param name="allowNull">is null allowed</param>
            <param name="isDynamic">is the request dynamic</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.MembersThatConfiguration">
            <summary>
            Configuration object for filtering members
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.AreNamed(System.String)">
            <summary>
            Are named a specific name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.StartsWith(System.String)">
            <summary>
            Member name starts with prefix
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.EndsWith(System.String)">
            <summary>
            Member name ends with
            </summary>
            <param name="postfix"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.Match(System.Func{System.Reflection.MemberInfo,System.Boolean})">
            <summary>
            Match a specific member
            </summary>
            <param name="matchMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.AreProperty(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Is member a property that matches
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.AreMethod(System.Func{System.Reflection.MethodInfo,System.Boolean})">
            <summary>
            Matched is the Memember is a Method
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Have a specific attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MembersThatConfiguration.Or">
            <summary>
            Or together the filters rather than using And
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MembersThatConfiguration.And">
            <summary>
            And together filters rather than using Or
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MembersThatConfiguration.Not">
            <summary>
            Reverses the logic for the next type filter
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MembersThatConfiguration.op_Implicit(Grace.DependencyInjection.Impl.MembersThatConfiguration)~System.Func{System.Reflection.MemberInfo,System.Boolean}">
            <summary>
            Implicitly convert to func
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.MethodInjectionInfo">
            <summary>
            information for injecting a method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MethodInjectionInfo.Method">
            <summary>
            Method being injected
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PartiallyClosedGenericPriorityAugmenter">
            <summary>
            Increases the priority of partially closed generics
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PartiallyClosedGenericPriorityAugmenter.Inspect``1(``0)">
            <summary>
            Inspect the activation strategy
            </summary>
            <typeparam name="T"></typeparam>
            <param name="strategy"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PropertyFieldInjectionSelector">
            <summary>
            injects fields and properties of a specific type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyFieldInjectionSelector.#ctor(System.Type,System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="memberType"></param>
            <param name="filter"></param>
            <param name="processAttributes"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.PropertyFieldInjectionSelector.LocateKey">
            <summary>
            Key to use during locate
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.PropertyFieldInjectionSelector.IsRequired">
            <summary>
            Is required
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyFieldInjectionSelector.GetPropertiesAndFields(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get a list of member injection info for a specific type
            </summary>
            <param name="type">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="request">request</param>
            <returns>members being injected</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyFieldInjectionSelector.GetMethods(System.Type,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get Methods to inject
            </summary>
            <param name="type">type being activated</param>
            <param name="injectionScope">injection scope</param>
            <param name="request">request</param>
            <returns>methods being injected</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration">
            <summary>
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.#ctor(Grace.DependencyInjection.IFluentDecoratorStrategyConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.ApplyAfterLifestyle">
            <summary>
            Apply decorator after lifestyle, by default it's before
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.As(System.Type)">
            <summary>
            Export as particular types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.When">
            <summary>
            Condition for decorator strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.WithCtorParam``2(System.Func{``0,``1})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.WithCtorParam``3(System.Func{``0,``1,``2})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.WithCtorParam``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.WithCtorParam``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentDecoratorStrategyConfiguration.WithCtorParam``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <typeparam name="TArg5"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration">
            <summary>
            forwards strategy configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type">type to export as</param>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed interface
            </summary>
            <param name="type">type to export as</param>
            <param name="key">key to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export as Name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export by interfaces
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned so the container does not track for disposal
            </summary>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Use specific constructor for use
            </summary>
            <param name="constructorInfo">constructor to use</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.ImportConstructorSelection(Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator)">
            <summary>
            Specify the constructor selection algorithm
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.ImportMembers(System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Import a specific member
            </summary>
            <param name="selector">selector method, can be null</param>
            <param name="injectMethods"></param>
            <returns>configuraiton object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.Lifestyle">
            <summary>
            Apply a lifestlye to export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Export only if function returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Assign a custom lifestyle to an export
            </summary>
            <param name="lifestyle"></param>
            <returns>configuraiton object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.When">
            <summary>
            Apply a condition on when to use strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Configure constructor parameter
            </summary>
            <typeparam name="TParam"></typeparam>
            <param name="paramFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.WithMetadata(System.Object,System.Object)">
            <summary>
            Export with specific metadata
            </summary>
            <param name="key">metadata key</param>
            <param name="value">metadata value</param>
            <returns>configuraiton object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Set the priority for the export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration.DefinesNamedScope(System.String)">
            <summary>
            Defines a custom scope when creating instance
            </summary>
            <param name="customscope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1">
            <summary>
            Base class for configurin an export strategy
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.Apply(System.Action{`0})">
            <summary>
            Apply an action to the export just after construction
            </summary>
            <param name="applyAction">action to apply to export upon construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type
            </summary>
            <param name="type">type to export as</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a particular type
            </summary>
            <typeparam name="TInterface">type to export as</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export as keyed type
            </summary>
            <param name="type">export type</param>
            <param name="key">key</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.AsKeyed``1(System.Object)">
            <summary>
            Export as a keyed type
            </summary>
            <typeparam name="TInterface">export type</typeparam>
            <param name="key">key to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export as specific name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.DefinesNamedScope(System.String)">
            <summary>
            Creates a new scope and then resolves decorators inside of it.
            </summary>
            <param name="namedScope"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.DisposalCleanupDelegate(System.Action{`0})">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.EnrichWithDelegate(System.Func{Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.StaticInjectionContext,`0,`0})">
            <summary>
            Enrich with delegate
            </summary>
            <param name="enrichmentDelegate">enrichment delegate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ExportMember``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Export a public member of the type (property, field or method with return value)
            </summary>
            <typeparam name="TValue">type to export</typeparam>
            <param name="memberExpression">member expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ExternallyOwned">
            <summary>
            Mark an export as externally owned means the container will not track and dispose the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Func{`0}})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Use specific constructor for use
            </summary>
            <param name="constructorInfo">constructor to use</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ImportConstructorSelection(Grace.DependencyInjection.Impl.Expressions.IConstructorExpressionCreator)">
            <summary>
            Use a specific constructor selection method
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ImportMembers(System.Func{System.Reflection.MemberInfo,System.Boolean},System.Boolean)">
            <summary>
            Mark specific members to be injected
            </summary>
            <param name="selector">select specific members, if null all public members will be injected</param>
            <param name="injectMethod"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Import a specific property
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property">property expression</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Import a specific method on the type
            </summary>
            <param name="method">method to import</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.Lifestyle">
            <summary>
            Assign a lifestyle to this export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.OnlyIf(System.Func{Grace.DependencyInjection.IExportRegistrationBlock,System.Boolean})">
            <summary>
            Export only if function returns true
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Export using a specific lifestyle
            </summary>
            <param name="lifestyle">lifestlye to use</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.When">
            <summary>
            Add a condition to when this export can be used
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithCtorCollectionParam``2">
            <summary>
            Import a collection allowing you to specify a filter and a sort order
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithCtorParam``2(System.Func{``0,``1})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithCtorParam``3(System.Func{``0,``1,``2})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithCtorParam``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithCtorParam``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithCtorParam``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <typeparam name="TArg5"></typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithMetadata(System.Object,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="key">metadata key</param>
            <param name="value">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ProxyFluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Set the priority for the export
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleDecoratorStrategyProvider">
            <summary>
            Simple class to return decorators
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleDecoratorStrategyProvider.#ctor(Grace.DependencyInjection.ICompiledDecoratorStrategy[])">
            <summary>
            default constructor
            </summary>
            <param name="decorators"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleDecoratorStrategyProvider.ProvideStrategies">
            <summary>
            Provide a list of decorator strategies
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleExportStrategyProvider">
            <summary>
            Simple class to return list of export strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategyProvider.#ctor(Grace.DependencyInjection.ICompiledExportStrategy[])">
            <summary>
            Default constructor
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategyProvider.ProvideExportStrategies">
            <summary>
            Get export strategies
            </summary>
            <returns>list of exports</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleExportWrapperProvider">
            <summary>
            Simple class that returns a list of wrapper strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportWrapperProvider.#ctor(Grace.DependencyInjection.ICompiledWrapperStrategy[])">
            <summary>
            Default constructor
            </summary>
            <param name="wrappers"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportWrapperProvider.ProvideWrappers">
            <summary>
            Provide list of wrappers
            </summary>
            <returns>list of wrappers</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IStrongMetadataInstanceProvider">
            <summary>
            Interface for creating strongly type metadata instances
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IStrongMetadataInstanceProvider.GetMetadata(System.Type,Grace.DependencyInjection.IActivationStrategyMetadata)">
            <summary>
            Create new instance of metadata type using provided metadata
            </summary>
            <param name="metadataType"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.StrongMetadataInstanceProvider">
            <summary>
            Class to create strongly typed instances
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.StrongMetadataInstanceProvider.GetMetadata(System.Type,Grace.DependencyInjection.IActivationStrategyMetadata)">
            <summary>
            
            </summary>
            <param name="metadataType"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.StrongMetadataInstanceProvider.GetConstructorParameters(System.Type,Grace.DependencyInjection.IActivationStrategyMetadata)">
            <summary>
            
            </summary>
            <param name="metadataType"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.StrongMetadataInstanceProvider.BindPropertyValues(System.Object,Grace.DependencyInjection.IActivationStrategyMetadata)">
            <summary>
            Bind metadata values to instance
            </summary>
            <param name="instance"></param>
            <param name="metadata"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.TypeActivationConfiguration">
            <summary>
            Contains the information required to create an activation expression
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ConstructorParametersList">
            <summary>
            list of cosntructor parameters
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.TypeActivationConfiguration.EncrichmentDelegateList">
            <summary>
            list of enrichment delegates
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.TypeActivationConfiguration.MemberInjectorList">
            <summary>
            list of member injection selectors
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.TypeActivationConfiguration.MethodInjectionList">
            <summary>
            list of method injection info
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypeActivationConfiguration.#ctor(System.Type,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ActivationType">
            <summary>
            Type being activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ActivationStrategy">
            <summary>
            Strategy that owns this configuration
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ActivationMethod">
            <summary>
            Method to call upon activation
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.Lifestyle">
            <summary>
            Lifestyle for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.SupportsDecorators">
            <summary>
            does this strategy support decorators
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.DisposalDelegate">
            <summary>
            delegate to call when disposed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ExternallyOwned">
            <summary>
            Externally owned strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.SelectedConstructor">
            <summary>
            Constructor to use when creating instance
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ConstructorParameters">
            <summary>
            List of constructor parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ConstructorParameter(Grace.DependencyInjection.Impl.ConstructorParameterInfo)">
            <summary>
            Add constructor parameter to configuration
            </summary>
            <param name="info"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.EnrichmentDelegates">
            <summary>
            List of enrichment delegates
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypeActivationConfiguration.EnrichmentDelegate(System.Object)">
            <summary>
            Add enrichment delegate
            </summary>
            <param name="enrichmentDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.MemberInjectionSelectors">
            <summary>
            List of member injection selectors
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypeActivationConfiguration.MemberInjectionSelector(Grace.DependencyInjection.Impl.IMemberInjectionSelector)">
            <summary>
            Add member injection selector to configuration
            </summary>
            <param name="selector"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.MethodInjections">
            <summary>
            List of methods to inject
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.ConstructorSelectionMethod">
            <summary>
            Constructor selection method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypeActivationConfiguration.CustomScopeName">
            <summary>
            If not null then type will be created in new scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypeActivationConfiguration.MethodInjection(Grace.DependencyInjection.Impl.MethodInjectionInfo)">
            <summary>
            add method injection to list
            </summary>
            <param name="methodInjection"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypeActivationConfiguration.CloneToType(System.Type)">
            <summary>
            Clone configuration
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.TypesThatConfiguration">
            <summary>
            Represents a configuration for a type filter
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveProperty(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveProperty``1(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <typeparam name="T">property type</typeparam>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveProperty(System.Type,System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyType">property type</param>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreBasedOn``1">
            <summary>
            Filters types based on a particular
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreBasedOn(System.Type)">
            <summary>
            Filters types that are based on
            </summary>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreBasedOn(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to provide a method that will test a classes base classes (base class and interfaces)
            </summary>
            <param name="typeFilter">based on type filter</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.Match(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds a type filter directly
            </summary>
            <param name="typeFilter">type filter</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.ArePublic">
            <summary>
            Adds a type filter that returns true if the type is public
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreNotPublic">
            <summary>
            Adds a type filter that returns true if the type is private
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreConstructedGeneric">
            <summary>
            Adds a type filter that returns true if the type is constructed generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreOpenGeneric">
            <summary>
            Adds a type filter that returns true if the type is an open generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveAttribute(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds type filter that filters based uppon a classes attribute
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">test string</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.Contains(System.String)">
            <summary>
            Creates a new type filter that returns true if the name contains the provided string
            </summary>
            <param name="name">string to test for</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypesThatConfiguration.Not">
            <summary>
            Reverses the logic for the next type filter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypesThatConfiguration.Or">
            <summary>
            Or together the filters rather than using And
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypesThatConfiguration.And">
            <summary>
            And together filters rather than using Or
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy">
            <summary>
            Base strategy for wrappers to inherit from
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.ActivationDelegates">
            <summary>
            Activation delegates
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType">type being activated</param>
            <param name="injectionScope">scope for strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.GetActivationConfiguration(System.Type)">
            <summary>
            Get activation configuration for strategy
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.StrategyType">
            <summary>
            Type of activation strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.BaseWrapperStrategy.CompileDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Compile a delegate
            </summary>
            <param name="scope">scope</param>
            <param name="compiler">compiler</param>
            <param name="activationType">activation type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DefaultWrapperCollectionProvider">
            <summary>
            Provides a collection of default wrappers
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DefaultWrapperCollectionProvider.ProvideCollection(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Provide collection of wrappers
            </summary>
            <param name="scope">scope</param>
            <returns>wrapper collection container</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy">
            <summary>
            Strategy for creating a delegate with five arguements
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType">activation type</param>
            <param name="injectionScope">injection scope</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.DelegateExpression`7">
            <summary>
            Helper class that creates delegate expression
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TDelegate"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.DelegateExpression`7.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope">scope</param>
            <param name="request">request</param>
            <param name="injectionContextCreator">injection context creator</param>
            <param name="strategy">strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.DelegateExpression`7.CreateDelegate(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method that is called each time a delegate needs to be created
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.DelegateExpression`7.FuncClass">
            <summary>
            Helper class that provides method that is turned into delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.DelegateExpression`7.FuncClass.#ctor(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,Grace.DependencyInjection.Impl.IInjectionContextCreator,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="action"></param>
            <param name="injectionContextCreator"></param>
            <param name="arg1Id"></param>
            <param name="arg2Id"></param>
            <param name="arg3Id"></param>
            <param name="arg4Id"></param>
            <param name="arg5Id"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFiveArgWrapperStrategy.DelegateExpression`7.FuncClass.Func(`0,`1,`2,`3,`4)">
            <summary>
            Method invoked when delegate is executed
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="arg5"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy">
            <summary>
            Strategy to create four arg delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.DelegateExpression`6">
            <summary>
            Helper class that creates delegate upon request
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TDelegate"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.DelegateExpression`6.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.DelegateExpression`6.CreateDelegate(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method that is called to create delegate upon request
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.DelegateExpression`6.FuncClass">
            <summary>
            Helper class that has method that is turned into delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.DelegateExpression`6.FuncClass.#ctor(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,Grace.DependencyInjection.Impl.IInjectionContextCreator,System.String,System.String,System.String,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="action"></param>
            <param name="injectionContextCreator"></param>
            <param name="arg1Id"></param>
            <param name="arg2Id"></param>
            <param name="arg3Id"></param>
            <param name="arg4Id"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateFourArgWrapperStrategy.DelegateExpression`6.FuncClass.Func(`0,`1,`2,`3)">
            <summary>
            Delegate method
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy">
            <summary>
            Strategy class for creating delegate with no arguements
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.DelegateExpression`2">
            <summary>
            Helper class that creates delegate expression
            </summary>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TDelegate"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.DelegateExpression`2.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.DelegateExpression`2.CreateDelegate(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method that is called to create delegate
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.DelegateExpression`2.FuncClass">
            <summary>
            Helper class that has method that is turned into delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.DelegateExpression`2.FuncClass.#ctor(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,Grace.DependencyInjection.Impl.IInjectionContextCreator)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="action"></param>
            <param name="injectionContextCreator"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateNoArgWrapperStrategy.DelegateExpression`2.FuncClass.Func">
            <summary>
            Function that is created into delegate
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy">
            <summary>
            Strategy to create delegate that has one arguement
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.DelegateExpression`3">
            <summary>
            Helper class to create delegate expression
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TDelegate"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.DelegateExpression`3.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.DelegateExpression`3.CreateDelegate(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            MEthod to create delegate
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.DelegateExpression`3.FuncClass">
            <summary>
            Helper class that has method that is turned into delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.DelegateExpression`3.FuncClass.#ctor(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,Grace.DependencyInjection.Impl.IInjectionContextCreator,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="action"></param>
            <param name="injectionContextCreator"></param>
            <param name="arg1Id"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateOneArgWrapperStrategy.DelegateExpression`3.FuncClass.Func(`0)">
            <summary>
            MEthod that is turned into delegate
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy">
            <summary>
            Strategy for creating delegate with 3 args
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.DelegateExpression`5">
            <summary>
            Helper class that creates delegate expression
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TDelegate"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.DelegateExpression`5.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.DelegateExpression`5.CreateDelegate(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            MEthod that creates delegate
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.DelegateExpression`5.FuncClass">
            <summary>
            Helper class that has actual delegate method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.DelegateExpression`5.FuncClass.#ctor(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,Grace.DependencyInjection.Impl.IInjectionContextCreator,System.String,System.String,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="action"></param>
            <param name="injectionContextCreator"></param>
            <param name="arg1Id"></param>
            <param name="arg2Id"></param>
            <param name="arg3Id"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateThreeArgWrapperStrategy.DelegateExpression`5.FuncClass.Func(`0,`1,`2)">
            <summary>
            delegate method
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy">
            <summary>
            Strategy for creating delegates with two arguements
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default cosntructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.DelegateExpression`4">
            <summary>
            Helper class that creates delegate
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TDelegate"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.DelegateExpression`4.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default cosntructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.DelegateExpression`4.CreateDelegate(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method that creates delegate
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.DelegateExpression`4.FuncClass">
            <summary>
            Helper class that has method that is created into delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.DelegateExpression`4.FuncClass.#ctor(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,Grace.DependencyInjection.Impl.IInjectionContextCreator,System.String,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="action"></param>
            <param name="injectionContextCreator"></param>
            <param name="arg1Id"></param>
            <param name="arg2Id"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.DelegateTwoArgWrapperStrategy.DelegateExpression`4.FuncClass.Func(`0,`1)">
            <summary>
            MEthod that is converted into delegate
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncFiveArgWrapperStrategy">
            <summary>
            Strategy for creating a Func with 5 arguements
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFiveArgWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFiveArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFiveArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncFiveArgWrapperStrategy.FuncExpression`6">
            <summary>
            Helper class that creates func with 5 arguements
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFiveArgWrapperStrategy.FuncExpression`6.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFiveArgWrapperStrategy.FuncExpression`6.CreateFunc(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method that creates Func
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncFourArgWrapperStrategy">
            <summary>
            Strategy for creating Func with 4 args
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFourArgWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFourArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFourArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncFourArgWrapperStrategy.FuncExpression`5">
            <summary>
            Helper class that creates Func with 4 arguements
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFourArgWrapperStrategy.FuncExpression`5.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncFourArgWrapperStrategy.FuncExpression`5.CreateFunc(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method that creates new Func with 4 args
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncOneArgWrapperStrategy">
            <summary>
            Strategy for creating Func with one arguement
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncOneArgWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncOneArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncOneArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncOneArgWrapperStrategy.FuncExpression`2">
            <summary>
            Helper class for creating one arg Func
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncOneArgWrapperStrategy.FuncExpression`2.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncOneArgWrapperStrategy.FuncExpression`2.CreateFunc(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method that creates one arg Func
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncThreeArgWrapperStrategy">
            <summary>
            Strategy for creating Func with 3 args
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncThreeArgWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncThreeArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncThreeArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncThreeArgWrapperStrategy.FuncExpression`4">
            <summary>
            Helper class that creates Func with 3 args
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncThreeArgWrapperStrategy.FuncExpression`4.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncThreeArgWrapperStrategy.FuncExpression`4.CreateFunc(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method creates 3 arg Func
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncTwoArgWrapperStrategy">
            <summary>
            Strategy for creating two argument Func
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncTwoArgWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncTwoArgWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncTwoArgWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncTwoArgWrapperStrategy.FuncExpression`3">
            <summary>
            Helper class for creating 2 arg Func
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncTwoArgWrapperStrategy.FuncExpression`3.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.Impl.IInjectionContextCreator,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="injectionContextCreator"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncTwoArgWrapperStrategy.FuncExpression`3.CreateFunc(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method creates 2 arg Func
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncWrapperStrategy">
            <summary>
            Wrapper for Func&lt;T&gt;
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="type">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.FuncWrapperStrategy.FuncExpression`1">
            <summary>
            Func helper class 
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncWrapperStrategy.FuncExpression`1.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.FuncWrapperStrategy.FuncExpression`1.CreateFunc(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Create func
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.IDefaultWrapperCollectionProvider">
            <summary>
            Provide a list of compiled wrappers
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.IDefaultWrapperCollectionProvider.ProvideCollection(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Provide container for wrappers
            </summary>
            <param name="scope">scope</param>
            <returns>wrapper collection container</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy">
            <summary>
            Wrapper for Lazy&lt;T,IActivationStrategyMetadata&gt;
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.IStrongMetadataInstanceProvider,Grace.DependencyInjection.Impl.Expressions.IWrapperExpressionCreator)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
            <param name="strongMetadataInstanceProvider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="type">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy.CompileDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Compile a delegate
            </summary>
            <param name="scope">scope</param>
            <param name="compiler">compiler</param>
            <param name="activationType">activation type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy.LazyExpression`2">
            <summary>
            Lazy expression helper class
            </summary>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TMetadata"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy.LazyExpression`2.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationStrategy,`1)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationStrategy"></param>
            <param name="metadata"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyMetadataWrapperStrategy.LazyExpression`2.CreateLazy(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Create lazy instance
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.LazyWrapperStrategy">
            <summary>
            Wrapper strategy for Lazy&lt;T&gt;
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="type">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.LazyWrapperStrategy.LazyExpression`1">
            <summary>
            Lazy expression helper class
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyWrapperStrategy.LazyExpression`1.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <param name="activationStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.LazyWrapperStrategy.LazyExpression`1.CreateLazy(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Create lazy instance
            </summary>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.MetaWrapperStrategy">
            <summary>
            Wrapper for Meta&lt;T&gt;
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.MetaWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.MetaWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="wrappedType">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.MetaWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.MetaWrapperStrategy.CompileDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Compiles delegate
            </summary>
            <param name="scope"></param>
            <param name="compiler"></param>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.OwnedWrapperStrategy">
            <summary>
            Wrapper strategy for Owned&lt;T&gt;
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.OwnedWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.OwnedWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get type that wrapper wraps
            </summary>
            <param name="wrappedType">wrapper type</param>
            <returns>type that has been wrapped</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.OwnedWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.Wrappers.StronglyTypedMetadataWrapperStrategy">
            <summary>
            Wrapper strategy for strongly typed metadata
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.StronglyTypedMetadataWrapperStrategy.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.Impl.IStrongMetadataInstanceProvider)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
            <param name="strongMetadataInstanceProvider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.StronglyTypedMetadataWrapperStrategy.#ctor(System.Type,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType">type being activated</param>
            <param name="injectionScope">scope for strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.StronglyTypedMetadataWrapperStrategy.GetWrappedType(System.Type)">
            <summary>
            Get the type that is being wrapped
            </summary>
            <param name="type">requested type</param>
            <returns>wrapped type</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.StronglyTypedMetadataWrapperStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.Wrappers.StronglyTypedMetadataWrapperStrategy.CompileDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Compiles delegate
            </summary>
            <param name="scope"></param>
            <param name="compiler"></param>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionExtension">
            <summary>
            C# extenion class to inject object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionExtension.Inject(Grace.DependencyInjection.IExportLocatorScope,System.Object,System.Object)">
            <summary>
            Inject instance with dependencies
            </summary>
            <param name="scope">export locator scope</param>
            <param name="instance">instance to inject</param>
            <param name="extraData">extra data, can be null</param>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionExtension.InjectionHashTreeHolder">
            <summary>
            
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionScopeConfiguration">
            <summary>
            Configuration for injection scope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionScopeConfiguration.#ctor(Grace.DependencyInjection.Impl.ImplementationFactory)">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionScopeConfiguration.Grace#DependencyInjection#IInjectionScopeConfiguration#SetInjectionScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            internal method used by the container
            </summary>
            <param name="scope">owning scope</param>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.Behaviors">
            <summary>
            Allows you to configure how to construct compiled exports.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.CatchDisposalExceptions">
            <summary>
            Catch exceptions on disposal, false by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.Implementation">
            <summary>
            This the containers internal DI container. If you want to change any implementation you would add them here
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.CacheArraySize">
            <summary>
            Size of the array used to cache execution delegates. By default it's 64, if you wish to change this make sure it's a positive power of 2
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.ExportStrategyArraySize">
            <summary>
            Size of array used to cache export strategies. By default it's 16, if you wish to change this make sure it's a positive power of 2
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.AutoRegisterUnknown">
            <summary>
            Register concrete implementation that are unknown
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.AutoRegistrationLifestylePicker">
            <summary>
            Lifestyle picker to be used when 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.ExportAsBase">
            <summary>
            Export as type and base implementations, false by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.DisposalScopeProvider">
            <summary>
            Use custom disposal scopes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.ExportByInterfaceFilter">
            <summary>
            Filter interfaces to be exported
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.SupportFuncType">
            <summary>
            Support Func&lt;Type,object&gt; out of the box
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.Trace">
            <summary>
            Provide action that will be called for tracing purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.TrackDisposableTransients">
            <summary>
            Should the container track disposable transients
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionScopeConfiguration.InjectIDisposable">
            <summary>
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionScopeConfiguration.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionScopeConfiguration.DefaultInterfaceFilter(System.Type,System.Type)">
            <summary>
            Default interface filter
            </summary>
            <returns></returns>
        </member>
        <member name="F:Grace.DependencyInjection.InjectionScopeConfiguration.DefaultImplementation">
            <summary>
            Default implementation factor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionScopeConfiguration.#cctor">
            <summary>
            static constructor that sets up a default implementation for the DI container
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionTargetInfo">
            <summary>
            information for a specific instance of a type being injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionTargetInfo.#ctor(Grace.DependencyInjection.Impl.IAttributeDiscoveryService,System.Type,Grace.DependencyInjection.IActivationStrategy,System.Object,System.String,Grace.DependencyInjection.RequestType,System.Type,System.Boolean,System.Object,System.String)">
            <summary>
            Default cosntructor
            </summary>
            <param name="attributeDiscoveryService"></param>
            <param name="injectionType"></param>
            <param name="requestingStrategy"></param>
            <param name="injectionTarget"></param>
            <param name="injectionTargetName"></param>
            <param name="injectionDependencyType"></param>
            <param name="locatedType"></param>
            <param name="isRequired"></param>
            <param name="defaultValue"></param>
            <param name="uniqueId"></param>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.RequestingStrategy">
            <summary>
            Requesting strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.InjectionTypeAttributes">
            <summary>
            These are the attributes for the class that it's being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.InjectionTargetName">
            <summary>
            Name of target being injected, parameter name, property name, or fieldName
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.InjectionDependencyType">
            <summary>
            Type of injection being done, constructor, property, or method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.InjectionMemberAttributes">
            <summary>
            Attributes on the Constructor, Method, or Property being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.LocateType">
            <summary>
            Locate type being used
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.IsRequired">
            <summary>
            Is the injection required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.DefaultValue">
            <summary>
            Default value for injection
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionTargetInfo.UniqueId">
            <summary>
            Unique Id for request
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IWhenConditionConfiguration`1">
            <summary>
            Object used to configure a condition
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.MeetsCondition(Grace.DependencyInjection.Conditions.ICompiledCondition)">
            <summary>
            Use strategy when it meets condition
            </summary>
            <param name="condition">condition</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.MeetsCondition(System.Func{Grace.DependencyInjection.IActivationStrategy,Grace.DependencyInjection.StaticInjectionContext,System.Boolean})">
            <summary>
            Use strategy when it meets a condition
            </summary>
            <param name="condition">condition</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.TargetHas``1(System.Func{``0,System.Boolean})">
            <summary>
            Add a condition to use this export only when Target (parameter, property, method) has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.ClassHas(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Add a condition to use this export only when the class being injected into has a specific attribute
            </summary>
            <param name="attributeType"></param>
            <param name="testFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.ClassHas``1(System.Func{``0,System.Boolean})">
            <summary>
            Add a condition to use this export only when the class being injected into has a specific attribute
            </summary>
            <param name="testFunc"></param>
            <typeparam name="TAttribute">attribute</typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.MemberHas``1(System.Func{``0,System.Boolean})">
            <summary>
            Add a condition to use this export only when the member being injected into has a specific attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="testFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.InjectedInto``1">
            <summary>
            Use export when injecting into a specific type
            </summary>
            <typeparam name="TInjectedType">injected type</typeparam>
            <returns>configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.InjectedInto(System.Type[])">
            <summary>
            Use export when injected into one of the specified types
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWhenConditionConfiguration`1.InjectedInto(System.Func{System.Type,System.Boolean})">
            <summary>
            Injected into type using test method
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IWrapperOrExportActivationStrategy">
            <summary>
            Represents a wrapper strategy or an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IWrapperOrExportActivationStrategy.GetActivationStrategyDelegate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationStrategyCompiler,System.Type)">
            <summary>
            Get an activation strategy for this delegate
            </summary>
            <param name="scope">injection scope</param>
            <param name="compiler"></param>
            <param name="activationType">activation type</param>
            <returns>activation delegate</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IWrapperOrExportActivationStrategy.GetActivationExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest)">
            <summary>
            Get an activation expression for this strategy
            </summary>
            <param name="scope"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.LifestyleType">
            <summary>
            Generalized type for lifestyle
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.LifestyleType.Transient">
            <summary>
            Lifestyle is roughly transient (PerObjectGraph, PerAncestorType)
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.LifestyleType.Scoped">
            <summary>
            Singleton that is tied to a scope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.LifestyleType.Singleton">
            <summary>
            Singleton for the whole container
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.ICompiledLifestyle">
            <summary>
            Represents a lifestyle that can be used for exports
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.ICompiledLifestyle.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ICompiledLifestyle.Clone">
            <summary>
            Clone the lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ICompiledLifestyle.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1">
            <summary>
            Configuration object for picking a lifestyle
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.Custom(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Use custom lifestyle
            </summary>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.Singleton">
            <summary>
            Create one instance for the container including all child scopes and lifetime scopes
            </summary>
            <returns>configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.SingletonPerAncestor(System.Type,System.Boolean)">
            <summary>
            Create one instance per ancestor in the object graph
            </summary>
            <param name="ancestorType">ancestor type to scope to</param>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the object graph, set to true only if you believe there are multiple threads accessing one object graph</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.SingletonPerAncestor``1(System.Boolean)">
            <summary>
            Create one instance per ancestor in the object graph
            </summary>
            <typeparam name="TAncestor">ancestor type to scope to</typeparam>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the object graph, set to true only if you believe there are multiple threads accessing one object graph</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.SingletonPerNamedScope(System.String)">
            <summary>
            Create one instance per named scope, an exception is thrown if a scope by that name can't be found
            </summary>
            <param name="scopeName">scope name</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.SingletonPerObjectGraph(System.Boolean)">
            <summary>
            Create one instance per object graph
            </summary>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the object graph, set to true only if you believe there are multiple threads accessing one object graph</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.SingletonPerRequest(System.Boolean)">
            <summary>
            Create one instance per request, usually a lock is not needed
            </summary>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the request, set to true only if you believe there are multple threads accesing this export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.SingletonPerScope(System.Boolean)">
            <summary>
            Create one instance per scope, by default no lock is used if you think it's possible multiple threads will resolve this from the same scope then set to true
            </summary>
            <param name="locking">false by default, set to true if you have multiple threads resolving from the same scope </param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestylePicker`1.WeakSingleton">
            <summary>
            Create one instance per container but don't hold a strong reference
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.IPerRequestLifestyleProvider">
            <summary>
            Interface for providing singleton per lifestyle provide
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.IPerRequestLifestyleProvider.ProvideLifestyle">
            <summary>
            Provide contianer
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.LifestylePicker`1">
            <summary>
            Class used to configure lifestyles 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.#ctor(`0,System.Action{Grace.DependencyInjection.Lifestyle.ICompiledLifestyle})">
            <summary>
            Default constructor
            </summary>
            <param name="returnValue"></param>
            <param name="addLifestyle"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.Custom(Grace.DependencyInjection.Lifestyle.ICompiledLifestyle)">
            <summary>
            Use custom lifestyle
            </summary>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.Singleton">
            <summary>
            Create one instance for the container including all child scopes and lifetime scopes
            </summary>
            <returns>configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.SingletonPerObjectGraph(System.Boolean)">
            <summary>
            Create one instance per object graph
            </summary>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the object graph, set to true only if you believe there are multiple threads accessing one object graph</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.SingletonPerRequest(System.Boolean)">
            <summary>
            Create one instance per request, usually a lock is not needed
            </summary>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the request, set to true only if you believe there are multple threads accesing this export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.SingletonPerScope(System.Boolean)">
            <summary>
            Create one instance per scope, by default no lock is used if you think it's possible multiple threads will resolve form a scope then set locking to true
            </summary>
            <param name="locking">false by default, set to true if you have multiple threads resolving from the </param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.SingletonPerNamedScope(System.String)">
            <summary>
            Create one instance per named scope, 
            </summary>
            <param name="scopeName">scope name</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.WeakSingleton">
            <summary>
            Create one instance per container but don't hold a strong reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.SingletonPerAncestor(System.Type,System.Boolean)">
            <summary>
            Create one instance per ancestor in the object graph
            </summary>
            <param name="ancestorType">ancestor type to scope to</param>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the object graph, set to true only if you believe there are multiple threads accessing one object graph</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifestylePicker`1.SingletonPerAncestor``1(System.Boolean)">
            <summary>
            Create one instance per ancestor in the object graph
            </summary>
            <typeparam name="TAncestor">ancestor type to scope to</typeparam>
            <param name="locking">by default no lock is used and it's assumed there is only one thread of execution in the object graph, set to true only if you believe there are multiple threads accessing one object graph</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonLifestyle">
            <summary>
            Singleton lifestyle
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.ConstantExpression">
            <summary>
            Constant expression
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Clone">
            <summary>
            Clone lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerAncestor">
            <summary>
            Singleton per ancestor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestor.#ctor(System.Type,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="ancestorType"></param>
            <param name="guaranteeOnlyOne"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerAncestor.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestor.Clone">
            <summary>
            Clone the lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestor.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestor.GetValue``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,System.String)">
            <summary>
            Get value without locking
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="activationDelegate"></param>
            <param name="uniqueId"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestor.GetValueGuaranteeOnce``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,System.String)">
            <summary>
            Get a value using lock to guarantee only one is created
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="activationDelegate"></param>
            <param name="uniqueId"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle">
            <summary>
            Singleton per a named scope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle.UniqueId">
            <summary>
            Unique id
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle.CompiledDelegate">
            <summary>
            Compiled delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle.#ctor(System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="scopeName"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle.Clone">
            <summary>
            Clone the lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerNamedScopeLifestyle.GetValueFromScope``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.ActivationStrategyDelegate,System.String,System.String,Grace.DependencyInjection.StaticInjectionContext)">
            <summary>
            Get value from scope
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="creationDelegate"></param>
            <param name="uniqueId"></param>
            <param name="scopeName"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerObjectGraph">
            <summary>
            Singleton per object graph
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerObjectGraph.#ctor(System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="guaranteeOnlyOne"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerObjectGraph.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerObjectGraph.Clone">
            <summary>
            Clone the lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerObjectGraph.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerObjectGraph.GetValue``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,System.String)">
            <summary>
            Get value for object graph
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="activationDelegate"></param>
            <param name="uniqueId"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerObjectGraph.GetValueGuaranteeOnce``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ActivationStrategyDelegate,System.String)">
            <summary>
            Get value from context guarantee only one is created using lock
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="disposalScope"></param>
            <param name="context"></param>
            <param name="activationDelegate"></param>
            <param name="uniqueId"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle">
            <summary>
            lifestyle for per request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Clone">
            <summary>
            Clone the lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle">
            <summary>
            Singleton per scope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.UniqueId">
            <summary>
            Unique id
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.CompiledDelegate">
            <summary>
            Compiled delegate
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.ThreadSafe">
            <summary>
            Thread safe
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.#ctor(System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="threadSafe">Under normal circumstances set to false, only set to true if you know there are multiple threads
             accessing scope and you need to make sure only one instance is created</param>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Clone">
            <summary>
            Clone the lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.GetValueFromScope``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.ActivationStrategyDelegate,System.String)">
            <summary>
            Get value from scope with no lock 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="creationDelegate"></param>
            <param name="uniqueId"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.GetValueFromScopeThreadSafe``1(Grace.DependencyInjection.IExportLocatorScope,Grace.DependencyInjection.ActivationStrategyDelegate,System.String)">
            <summary>
            Get value from scope using lock
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <param name="creationDelegate"></param>
            <param name="uniqueId"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle">
            <summary>
            Weak singleton lifestyle
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.LifestyleType">
            <summary>
            Generalization for lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Clone">
            <summary>
            Clone the lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.ProvideLifestyleExpression(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IActivationExpressionRequest,System.Func{Grace.DependencyInjection.IActivationExpressionRequest,Grace.DependencyInjection.IActivationExpressionResult})">
            <summary>
            Provide an expression that uses the lifestyle
            </summary>
            <param name="scope">scope for the strategy</param>
            <param name="request">activation request</param>
            <param name="activationExpression">expression to create strategy type</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.GetValue``1(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Get value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="scope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.MembersThat">
            <summary>
            Static class that offers methods for filtering members
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.MembersThat.AreNamed(System.String)">
            <summary>
            Are named a specific name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.MembersThat.Match(System.Func{System.Reflection.MemberInfo,System.Boolean})">
            <summary>
            Members that match method
            </summary>
            <param name="matchMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.MembersThat.StartWith(System.String)">
            <summary>
            Member name starts with prefix
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.MembersThat.EndsWith(System.String)">
            <summary>
            Member name ends with
            </summary>
            <param name="postfix"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.MembersThat.AreProperty(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Is member a property that matches
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.MembersThat.AreMethod(System.Func{System.Reflection.MethodInfo,System.Boolean})">
            <summary>
            True if the member is a method and matches optional filter
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.MembersThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            True if the member has a specific attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Meta`1">
            <summary>
            Class that holds a dependency and it's metadata
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Meta`1.#ctor(`0,Grace.DependencyInjection.IActivationStrategyMetadata)">
            <summary>
            Default Constructor
            </summary>
            <param name="value">exported value</param>
            <param name="metadata">metadata associated with export</param>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`1.Value">
            <summary>
            Resolved Value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`1.Metadata">
            <summary>
            Metadata for the resolved value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Meta`2">
            <summary>
            Strongly typed metadata class
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMetadata"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Meta`2.#ctor(`0,`1)">
            <summary>
            Default Constructor
            </summary>
            <param name="value">exported value</param>
            <param name="metadata">metadata associated with export</param>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`2.Value">
            <summary>
            Resolved Value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`2.Metadata">
            <summary>
            Metadata for the resolved value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Owned`1">
            <summary>
            class that holds dependency and acts as a disposal scope for it and it's children
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Grace.DependencyInjection.Owned`1.Value">
            <summary>
            Resolved dependency
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Owned`1.SetValue(`0)">
            <summary>
            Set owned value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Scoped`1">
            <summary>
            Similar to Owned with the difference being a new scope is created and used to resolve instance 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Scoped`1.#ctor(Grace.DependencyInjection.IExportLocatorScope,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="scope"></param>
            <param name="scopeName"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Scoped`1.Instance">
            <summary>
            Instance 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Scoped`1.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="T:Grace.DependencyInjection.StaticInjectionContext">
            <summary>
            hold static information about the injection
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.StaticInjectionContext.#ctor(System.Type,System.Collections.Generic.IEnumerable{Grace.DependencyInjection.InjectionTargetInfo})">
            <summary>
            Default constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionStack"></param>
        </member>
        <member name="P:Grace.DependencyInjection.StaticInjectionContext.ActivationType">
            <summary>
            Type being activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.StaticInjectionContext.TargetInfo">
            <summary>
            Target information
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.StaticInjectionContext.InjectionStack">
            <summary>
            Injection context stack
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.TypesThat">
            <summary>
            Static class that offers type filters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveProperty(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveProperty``1(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <typeparam name="T">property type</typeparam>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveProperty(System.Type,System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyType">property type</param>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute(System.Func{System.Type,System.Boolean})">
            <summary>
            Provides a type filter for attributes, if true then the type will be used
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.Contains(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name contains the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreBasedOn``1">
            <summary>
            Adds a type filter that returns true when a class is based on the specified type
            </summary>
            <typeparam name="T">based on type</typeparam>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreBasedOn(System.Type)">
            <summary>
            Adds a type filter that returns true when a class is based on the specified type
            </summary>
            <param name="type">based on type</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreBasedOn(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds a type filter that filters a type based on it base type or interfaces
            </summary>
            <param name="typeFilter">type filter</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.Match(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds a type filter
            </summary>
            <param name="matchFilter"></param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.ArePublic">
            <summary>
            Adds a type filter that returns true if the type is public
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreNotPublic">
            <summary>
            Adds a type filter that returns true if the type is private
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreConstructedGeneric">
            <summary>
            Adds a type filter that returns true if the type is constructed generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreOpenGeneric">
            <summary>
            Adds a type filter that returns true if the type is an open generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.Not">
            <summary>
            Not value
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1">
            <summary>
            Diagnostic class used for visual studio debugging
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.#ctor(Grace.DependencyInjection.IActivationStrategyCollectionContainer{`0})">
            <summary>
            default constructor
            </summary>
            <param name="container"></param>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategiesByType">
            <summary>
            Strategies by type
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategyListDebuggerView`1">
            <summary>
            Strategies debugger view
            </summary>
            <typeparam name="TStrategy"></typeparam>
        </member>
        <member name="M:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategyListDebuggerView`1.#ctor(System.Type,System.Collections.Generic.List{`1})">
            <summary>
            Default Constructor
            </summary>
            <param name="type"></param>
            <param name="strategies"></param>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategyListDebuggerView`1.Type">
            <summary>
            Type of strategies
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategyListDebuggerView`1.TypeName">
            <summary>
            Name for Type
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategyListDebuggerView`1.Items">
            <summary>
            Items
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategyListDebuggerView`1.DebuggerDisplayValue">
            <summary>
            Debugger display value
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyCollectionContainerDebuggerView`1.StrategyListDebuggerView`1.DebuggerDisplayName">
            <summary>
            Debugger display name
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.ActivationStrategyMetadataDebuggerView">
            <summary>
            Metadata debugger view
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.ActivationStrategyMetadataDebuggerView.#ctor(Grace.DependencyInjection.IActivationStrategyMetadata)">
            <summary>
            Default constructor
            </summary>
            <param name="metadata">metadata</param>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyMetadataDebuggerView.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyMetadataDebuggerView.ExportAs">
            <summary>
            Export as
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyMetadataDebuggerView.ExportAsKeyed">
            <summary>
            Export as keyed
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ActivationStrategyMetadataDebuggerView.Data">
            <summary>
            Data associated with strategy
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.CollectionDebuggerView`1">
            <summary>
            Debugger class for IEnumerables that need to be displayed
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.Diagnostics.CollectionDebuggerView`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="items"></param>
        </member>
        <member name="P:Grace.Diagnostics.CollectionDebuggerView`1.Items">
            <summary>
            Items
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView">
            <summary>
            Diagnostic class for configurable strategies
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.#ctor(Grace.DependencyInjection.IConfigurableActivationStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="configurableActivationStrategy"></param>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.ActivationType">
            <summary>
            Type being activated
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.ExternallyOwned">
            <summary>
            Are entities created externally owned
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.HasConditions">
            <summary>
            Does the strategy have conditions
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.Dependencies">
            <summary>
            List of dependencies needed for this strategy
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.ExportAs">
            <summary>
            Export the strategy as types
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.ExportAsKeyed">
            <summary>
            Export as keyed type
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.Metadata">
            <summary>
            Metadata
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.Lifestyle">
            <summary>
            Lifestyle for container 
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ConfigurableActivationStrategyDebuggerView.Priority">
            <summary>
            Priority
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.ExtraDataContainerDebuggerView">
            <summary>
            Debugger view for extra data
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.ExtraDataContainerDebuggerView.#ctor(Grace.Data.IExtraDataContainer)">
            <summary>
            Default constructor
            </summary>
            <param name="extraDataContainer"></param>
        </member>
        <member name="P:Grace.Diagnostics.ExtraDataContainerDebuggerView.Items">
            <summary>
            Items in extra data
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.ImmutableHashTreeDebuggerView`2">
            <summary>
            Class for debugger
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Grace.Diagnostics.ImmutableHashTreeDebuggerView`2.#ctor(Grace.Data.Immutable.ImmutableHashTree{`0,`1})">
            <summary>
            Default constructor
            </summary>
            <param name="hashTree"></param>
        </member>
        <member name="P:Grace.Diagnostics.ImmutableHashTreeDebuggerView`2.Keys">
            <summary>
            Keys for hash tree
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ImmutableHashTreeDebuggerView`2.Values">
            <summary>
            Values
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.ImmutableHashTreeDebuggerView`2.Items">
            <summary>
            Items
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.KeyValuePairDebuggerView`2">
            <summary>
            Debugger view for hash tree entries
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Grace.Diagnostics.KeyValuePairDebuggerView`2.#ctor(`0,`1)">
            <summary>
            Default constructor
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:Grace.Diagnostics.KeyValuePairDebuggerView`2.Key">
            <summary>
            Key for entry
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.KeyValuePairDebuggerView`2.Value">
            <summary>
            Value for entry
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.KeyValuePairDebuggerView`2.DebuggerDisplayString">
            <summary>
            Debugger display string
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.KeyValuePairDebuggerView`2.DebuggerNameDisplayString">
            <summary>
            Debugger value string
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.ImmutableLinkedListDebugView`1">
            <summary>
            Class for debugger view
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.Diagnostics.ImmutableLinkedListDebugView`1.#ctor(Grace.Data.Immutable.ImmutableLinkedList{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="immutableLinkedList"></param>
        </member>
        <member name="P:Grace.Diagnostics.ImmutableLinkedListDebugView`1.Items">
            <summary>
            Items in list
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.InjectionScopeDebuggerView">
            <summary>
            Debugger view for injection scope
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.InjectionScopeDebuggerView.#ctor(Grace.DependencyInjection.IExportLocatorScope)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.Configuration">
            <summary>
            Scope Configuration
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.ExtraData">
            <summary>
            Extra data for scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.Name">
            <summary>
            Name of the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.ScopeId">
            <summary>
            Scope id
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.Exports">
            <summary>
            Exports in the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.ExportByType">
            <summary>
            Exports by type
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.Decorators">
            <summary>
            Decorators for the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.Wrappers">
            <summary>
            Wrappers for the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.PossibleMissingDependencies">
            <summary>
            List of possible missing dependencies in this scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDebuggerView.ContainerExceptions">
            <summary>
            List of exceptions discovered while looking for dependencies
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.InjectionScopeDiagnostics">
            <summary>
            Diagnostic class for injection scope
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.InjectionScopeDiagnostics.#ctor(Grace.DependencyInjection.IExportLocatorScope)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionScope"></param>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostics.PossibleMissingDependencies">
            <summary>
            List of possible missing dependencies in this scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostics.ContainerExceptions">
            <summary>
            List of exceptions discovered while looking for dependencies
            </summary>
        </member>
        <member name="T:Grace.Utilities.GenericComparer`1">
            <summary>
            Helper class that implement IComparer 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.Utilities.GenericComparer`1.#ctor(System.Comparison{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Grace.Utilities.GenericComparer`1.#ctor(System.Func{`0,System.IComparable})">
            <summary>
            Constructor that takes method for getting comparable properties from T
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Grace.Utilities.GenericComparer`1.Compare(`0,`0)">
            <summary>Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.</summary>
            <returns>A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />, as shown in the following table.Value Meaning Less than zero<paramref name="x" /> is less than <paramref name="y" />.Zero<paramref name="x" /> equals <paramref name="y" />.Greater than zero<paramref name="x" /> is greater than <paramref name="y" />.</returns>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
        </member>
        <member name="T:Grace.Utilities.GenericFilterGroup`1">
            <summary>
            Generic filter group 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.Utilities.GenericFilterGroup`1.#ctor(System.Func{`0,System.Boolean}[])">
            <summary>
            Default Constructor
            </summary>
            <param name="typeFilters"></param>
        </member>
        <member name="P:Grace.Utilities.GenericFilterGroup`1.UseOr">
            <summary>
            Or together the filters rather than And them
            </summary>
        </member>
        <member name="M:Grace.Utilities.GenericFilterGroup`1.Add(System.Func{`0,System.Boolean})">
            <summary>
            Add filter to filter group
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Grace.Utilities.GenericFilterGroup`1.op_Implicit(Grace.Utilities.GenericFilterGroup{`0})~System.Func{`0,System.Boolean}">
            <summary>
            Automatically convert from TypefilterGroup to Func(Type,bool)
            </summary>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.GenericFilterGroup`1.InternalFilter(`0)">
            <summary>
            Internal method that does the filtering 
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Utilities.InlineMethod">
            <summary>
            Helper class for constants for inlining methods
            </summary>
        </member>
        <member name="F:Grace.Utilities.InlineMethod.Value">
            <summary>
            Value for lining method
            </summary>
        </member>
        <member name="T:Grace.Utilities.ReflectionHelper">
            <summary>
            Static helper class for reflection methods
            </summary>
        </member>
        <member name="M:Grace.Utilities.ReflectionHelper.DoesTypeMeetGenericConstraints(System.Type,System.Type)">
            <summary>
            A helper to check to see if a generic parameter type meets the specified constraints
            </summary>
            <param name="genericParameterType">The generic parameter type</param>
            <param name="exported">The type parameter on the exported class</param>
            <returns>True if the type meets the constraints, otherwise false</returns>
        </member>
        <member name="M:Grace.Utilities.ReflectionHelper.CreateClosedExportTypeFromRequestingType(System.Type,System.Type)">
            <summary>
            Creates a closed type using the requested type parameters.
            it will return null if it's not possible
            </summary>
            <param name="exportedType"></param>
            <param name="requestedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.ReflectionHelper.HasDefaultConstructor(System.Type)">
            <summary>
            Determines if the type has a default constructor
            </summary>
            <param name="type">The type to check</param>
            <returns>
            True if the item has a default constructor, otherwise false
            </returns>
        </member>
        <member name="M:Grace.Utilities.ReflectionHelper.GetMemeberType(System.Reflection.MemberInfo)">
            <summary>
            Get the type for a specific MemberInfo
            </summary>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.ReflectionHelper.DoesTypeMeetGenericAttributes(System.Type,System.Type)">
            <summary>
            A helper method that checks to see if the type meets the applied constraints on the generic
            </summary>
            <param name="genericParameterType">
            The type parameter on the generic
            </param>
            <param name="exported">The type parameter on the exported class</param>
            <returns>True if the item meets the constraints on the generic, otherwise false</returns>
        </member>
        <member name="T:Grace.Utilities.UniqueStringId">
            <summary>
            Static class for generating unique id within the process space
            </summary>
        </member>
        <member name="F:Grace.Utilities.UniqueStringId.Prefix">
            <summary>
            Prefix for all string id's
            </summary>
        </member>
        <member name="M:Grace.Utilities.UniqueStringId.Generate">
            <summary>
            Generate string that is unique to this process
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
